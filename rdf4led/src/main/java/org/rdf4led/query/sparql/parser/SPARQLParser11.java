/* Generated By:JavaCC: Do not edit this line. SPARQLParser11.java */
package org.rdf4led.query.sparql.parser;

import org.rdf4led.query.path.*;
import org.rdf4led.query.sparql.Query;
import org.rdf4led.query.expr.Expr;
import org.rdf4led.query.expr.ExprList;
import org.rdf4led.query.expr.aggs.Aggregator;
import org.rdf4led.query.sparql.syntax.*;

import java.util.List;

public class SPARQLParser11<Node> extends SPARQLParserBase<Node>
    implements SPARQLParser11Constants {
  boolean allowAggregatesInExpressions = false;

  public final void QueryUnit() throws ParseException {
    startQuery();
    Query();
    jj_consume_token(0);
    finishQuery();
  }

  public final void Query() throws ParseException {
    Prologue();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SELECT:
        SelectQuery();
        break;
      case CONSTRUCT:
        ConstructQuery();
        break;
      case DESCRIBE:
        DescribeQuery();
        break;
      case ASK:
        AskQuery();
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    ValuesClause();
  }

  public final void Prologue() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case BASE:
        case PREFIX:;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case BASE:
          BaseDecl();
          break;
        case PREFIX:
          PrefixDecl();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    }
  }

  public final void BaseDecl() throws ParseException {
    String iri;
    jj_consume_token(BASE);
    iri = IRIREF();
    getPrologue().setBaseURI(iri);
  }

  public final void PrefixDecl() throws ParseException {
    Token t;
    String iri;
    jj_consume_token(PREFIX);
    t = jj_consume_token(PNAME_NS);
    iri = IRIREF();
    String s = fixupPrefix(t.image, t.beginLine, t.beginColumn);
    getPrologue().setPrefix(s, iri);
  }

  public final void SelectQuery() throws ParseException {
    SelectClause();
    label_2:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case FROM:;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
      }
      DatasetClause();
    }
    WhereClause();
    SolutionModifier();
  }

  public final void SubSelect() throws ParseException {
    SelectClause();
    WhereClause();
    SolutionModifier();
    ValuesClause();
  }

  public final void SelectClause() throws ParseException {
    Node v;
    Expr<Node> expr;
    Node n;
    jj_consume_token(SELECT);
    getQuery().setQuerySelectType();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case DISTINCT:
      case REDUCED:
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            jj_consume_token(DISTINCT);
            getQuery().setDistinct(true);
            break;
          case REDUCED:
            jj_consume_token(REDUCED);
            getQuery().setReduced(true);
            break;
          default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
    }
    allowAggregatesInExpressions = true;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case VAR1:
      case VAR2:
      case LPAREN:
        label_3:
        while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case VAR1:
            case VAR2:
              v = Var();
              getQuery().addResultVar(v);
              break;
            case LPAREN:
              v = null;
              jj_consume_token(LPAREN);
              expr = Expression();
              jj_consume_token(AS);
              v = Var();
              jj_consume_token(RPAREN);
              getQuery().addResultVar(v, expr);
              getQuery().setQueryResultStar(false);
              break;
            default:
              jj_la1[6] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
          }
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case VAR1:
            case VAR2:
            case LPAREN:;
              break;
            default:
              jj_la1[7] = jj_gen;
              break label_3;
          }
        }
        break;
      case STAR:
        jj_consume_token(STAR);
        getQuery().setQueryResultStar(true);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    allowAggregatesInExpressions = false;
  }

  public final void ConstructQuery() throws ParseException {
    Template<Node> t;
    TripleCollectorBGP<Node> acc = createTripleCollectorBGP();
    jj_consume_token(CONSTRUCT);
    getQuery().setQueryConstructType();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LBRACE:
        t = ConstructTemplate();
        getQuery().setConstructTemplate(t);
        label_4:
        while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FROM:;
              break;
            default:
              jj_la1[9] = jj_gen;
              break label_4;
          }
          DatasetClause();
        }
        WhereClause();
        SolutionModifier();
        break;
      case FROM:
      case WHERE:
        label_5:
        while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FROM:;
              break;
            default:
              jj_la1[10] = jj_gen;
              break label_5;
          }
          DatasetClause();
        }
        jj_consume_token(WHERE);
        jj_consume_token(LBRACE);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case BLANK_NODE_LABEL:
          case VAR1:
          case VAR2:
          case TRUE:
          case FALSE:
          case INTEGER:
          case DECIMAL:
          case DOUBLE:
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case STRING_LITERAL1:
          case STRING_LITERAL2:
          case STRING_LITERAL_LONG1:
          case STRING_LITERAL_LONG2:
          case LPAREN:
          case NIL:
          case LBRACKET:
          case ANON:
            TriplesTemplate(acc);
            break;
          default:
            jj_la1[11] = jj_gen;
            ;
        }
        jj_consume_token(RBRACE);
        SolutionModifier();
        t = createTemplate(acc.getBGP());
        getQuery().setConstructTemplate(t);
        ElementPathBlock<Node> epb = createElementPathBlock(acc.getBGP());
        ElementGroup<Node> elg = createElementGroup();
        elg.addElement(epb);
        getQuery().setQueryPattern(elg);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  public final void DescribeQuery() throws ParseException {
    Node n;
    jj_consume_token(DESCRIBE);
    getQuery().setQueryDescribeType();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case VAR1:
      case VAR2:
        label_6:
        while (true) {
          n = VarOrIri();
          getQuery().addDescribeNode(n);
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IRIref:
            case PNAME_NS:
            case PNAME_LN:
            case VAR1:
            case VAR2:;
              break;
            default:
              jj_la1[13] = jj_gen;
              break label_6;
          }
        }
        getQuery().setQueryResultStar(false);
        break;
      case STAR:
        jj_consume_token(STAR);
        getQuery().setQueryResultStar(true);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    label_7:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case FROM:;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_7;
      }
      DatasetClause();
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case WHERE:
      case LBRACE:
        WhereClause();
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
    }
    SolutionModifier();
  }

  public final void AskQuery() throws ParseException {
    jj_consume_token(ASK);
    getQuery().setQueryAskType();
    label_8:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case FROM:;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_8;
      }
      DatasetClause();
    }
    WhereClause();
    SolutionModifier();
  }

  public final void DatasetClause() throws ParseException {
    jj_consume_token(FROM);
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        DefaultGraphClause();
        break;
      case NAMED:
        NamedGraphClause();
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  public final void DefaultGraphClause() throws ParseException {
    String iri;
    iri = SourceSelector();
    getQuery().addGraphURI(iri);
  }

  public final void NamedGraphClause() throws ParseException {
    String iri;
    jj_consume_token(NAMED);
    iri = SourceSelector();
    getQuery().addNamedGraphURI(iri);
  }

  public final String SourceSelector() throws ParseException {
    String iri;
    iri = iri();
    {
      if (true) return iri;
    }
    throw new Error("Missing return statement in function");
  }

  public final void WhereClause() throws ParseException {
    Element el;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case WHERE:
        jj_consume_token(WHERE);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
    }
    startWherePattern();
    el = GroupGraphPattern();
    getQuery().setQueryPattern(el);
    finishWherePattern();
  }

  public final void SolutionModifier() throws ParseException {
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case GROUP:
        GroupClause();
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case HAVING:
        HavingClause();
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case ORDER:
        OrderClause();
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LIMIT:
      case OFFSET:
        LimitOffsetClauses();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
    }
  }

  public final void GroupClause() throws ParseException {
    jj_consume_token(GROUP);
    jj_consume_token(BY);
    label_9:
    while (true) {
      GroupCondition();
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case EXISTS:
        case NOT:
        case COUNT:
        case MIN:
        case MAX:
        case SUM:
        case AVG:
        case SAMPLE:
        case GROUP_CONCAT:
        case BOUND:
        case COALESCE:
        case IF:
        case BNODE:
        case IRI:
        case URI:
        case STR:
        case STRLANG:
        case STRDT:
        case DTYPE:
        case LANG:
        case LANGMATCHES:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case IS_NUMERIC:
        case REGEX:
        case SAME_TERM:
        case RAND:
        case ABS:
        case CEIL:
        case FLOOR:
        case ROUND:
        case CONCAT:
        case SUBSTR:
        case STRLEN:
        case REPLACE:
        case UCASE:
        case LCASE:
        case ENCODE_FOR_URI:
        case CONTAINS:
        case STRSTARTS:
        case STRENDS:
        case STRBEFORE:
        case STRAFTER:
        case YEAR:
        case MONTH:
        case DAY:
        case HOURS:
        case MINUTES:
        case SECONDS:
        case TIMEZONE:
        case TZ:
        case NOW:
        case UUID:
        case STRUUID:
        case MD5:
        case SHA1:
        case SHA256:
        case SHA384:
        case SHA512:
        case LPAREN:;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_9;
      }
    }
  }

  public final void GroupCondition() throws ParseException {
    Node v = null;
    Expr<Node> expr = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case EXISTS:
      case NOT:
      case COUNT:
      case MIN:
      case MAX:
      case SUM:
      case AVG:
      case SAMPLE:
      case GROUP_CONCAT:
      case BOUND:
      case COALESCE:
      case IF:
      case BNODE:
      case IRI:
      case URI:
      case STR:
      case STRLANG:
      case STRDT:
      case DTYPE:
      case LANG:
      case LANGMATCHES:
      case IS_URI:
      case IS_IRI:
      case IS_BLANK:
      case IS_LITERAL:
      case IS_NUMERIC:
      case REGEX:
      case SAME_TERM:
      case RAND:
      case ABS:
      case CEIL:
      case FLOOR:
      case ROUND:
      case CONCAT:
      case SUBSTR:
      case STRLEN:
      case REPLACE:
      case UCASE:
      case LCASE:
      case ENCODE_FOR_URI:
      case CONTAINS:
      case STRSTARTS:
      case STRENDS:
      case STRBEFORE:
      case STRAFTER:
      case YEAR:
      case MONTH:
      case DAY:
      case HOURS:
      case MINUTES:
      case SECONDS:
      case TIMEZONE:
      case TZ:
      case NOW:
      case UUID:
      case STRUUID:
      case MD5:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
        expr = BuiltInCall();
        getQuery().addGroupBy(null, expr);
        break;
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        expr = FunctionCall();
        getQuery().addGroupBy(null, expr);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        expr = Expression();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case AS:
            jj_consume_token(AS);
            v = Var();
            break;
          default:
            jj_la1[25] = jj_gen;
            ;
        }
        jj_consume_token(RPAREN);
        getQuery().addGroupBy(v, expr);
        break;
      case VAR1:
      case VAR2:
        v = Var();
        getQuery().addGroupBy(v);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  public final void HavingClause() throws ParseException {
    allowAggregatesInExpressions = true;
    jj_consume_token(HAVING);
    label_10:
    while (true) {
      HavingCondition();
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case EXISTS:
        case NOT:
        case COUNT:
        case MIN:
        case MAX:
        case SUM:
        case AVG:
        case SAMPLE:
        case GROUP_CONCAT:
        case BOUND:
        case COALESCE:
        case IF:
        case BNODE:
        case IRI:
        case URI:
        case STR:
        case STRLANG:
        case STRDT:
        case DTYPE:
        case LANG:
        case LANGMATCHES:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case IS_NUMERIC:
        case REGEX:
        case SAME_TERM:
        case RAND:
        case ABS:
        case CEIL:
        case FLOOR:
        case ROUND:
        case CONCAT:
        case SUBSTR:
        case STRLEN:
        case REPLACE:
        case UCASE:
        case LCASE:
        case ENCODE_FOR_URI:
        case CONTAINS:
        case STRSTARTS:
        case STRENDS:
        case STRBEFORE:
        case STRAFTER:
        case YEAR:
        case MONTH:
        case DAY:
        case HOURS:
        case MINUTES:
        case SECONDS:
        case TIMEZONE:
        case TZ:
        case NOW:
        case UUID:
        case STRUUID:
        case MD5:
        case SHA1:
        case SHA256:
        case SHA384:
        case SHA512:
        case LPAREN:;
          break;
        default:
          jj_la1[27] = jj_gen;
          break label_10;
      }
    }
    allowAggregatesInExpressions = false;
  }

  public final void HavingCondition() throws ParseException {
    Expr<Node> c;
    c = Constraint();
    getQuery().addHavingCondition(c);
  }

  public final void OrderClause() throws ParseException {
    allowAggregatesInExpressions = true;
    jj_consume_token(ORDER);
    jj_consume_token(BY);
    label_11:
    while (true) {
      OrderCondition();
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case ASC:
        case DESC:
        case EXISTS:
        case NOT:
        case COUNT:
        case MIN:
        case MAX:
        case SUM:
        case AVG:
        case SAMPLE:
        case GROUP_CONCAT:
        case BOUND:
        case COALESCE:
        case IF:
        case BNODE:
        case IRI:
        case URI:
        case STR:
        case STRLANG:
        case STRDT:
        case DTYPE:
        case LANG:
        case LANGMATCHES:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case IS_NUMERIC:
        case REGEX:
        case SAME_TERM:
        case RAND:
        case ABS:
        case CEIL:
        case FLOOR:
        case ROUND:
        case CONCAT:
        case SUBSTR:
        case STRLEN:
        case REPLACE:
        case UCASE:
        case LCASE:
        case ENCODE_FOR_URI:
        case CONTAINS:
        case STRSTARTS:
        case STRENDS:
        case STRBEFORE:
        case STRAFTER:
        case YEAR:
        case MONTH:
        case DAY:
        case HOURS:
        case MINUTES:
        case SECONDS:
        case TIMEZONE:
        case TZ:
        case NOW:
        case UUID:
        case STRUUID:
        case MD5:
        case SHA1:
        case SHA256:
        case SHA384:
        case SHA512:
        case LPAREN:;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_11;
      }
    }
    allowAggregatesInExpressions = false;
  }

  public final void OrderCondition() throws ParseException {
    int direction = 0;
    Expr<Node> expr = null;
    Node v = null;
    direction = Query.ORDER_DEFAULT;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case ASC:
      case DESC:
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case ASC:
            jj_consume_token(ASC);
            direction = Query.ORDER_ASCENDING;
            break;
          case DESC:
            jj_consume_token(DESC);
            direction = Query.ORDER_DESCENDING;
            break;
          default:
            jj_la1[29] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        expr = BrackettedExpression();
        break;
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case VAR1:
      case VAR2:
      case EXISTS:
      case NOT:
      case COUNT:
      case MIN:
      case MAX:
      case SUM:
      case AVG:
      case SAMPLE:
      case GROUP_CONCAT:
      case BOUND:
      case COALESCE:
      case IF:
      case BNODE:
      case IRI:
      case URI:
      case STR:
      case STRLANG:
      case STRDT:
      case DTYPE:
      case LANG:
      case LANGMATCHES:
      case IS_URI:
      case IS_IRI:
      case IS_BLANK:
      case IS_LITERAL:
      case IS_NUMERIC:
      case REGEX:
      case SAME_TERM:
      case RAND:
      case ABS:
      case CEIL:
      case FLOOR:
      case ROUND:
      case CONCAT:
      case SUBSTR:
      case STRLEN:
      case REPLACE:
      case UCASE:
      case LCASE:
      case ENCODE_FOR_URI:
      case CONTAINS:
      case STRSTARTS:
      case STRENDS:
      case STRBEFORE:
      case STRAFTER:
      case YEAR:
      case MONTH:
      case DAY:
      case HOURS:
      case MINUTES:
      case SECONDS:
      case TIMEZONE:
      case TZ:
      case NOW:
      case UUID:
      case STRUUID:
      case MD5:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
      case LPAREN:
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case EXISTS:
          case NOT:
          case COUNT:
          case MIN:
          case MAX:
          case SUM:
          case AVG:
          case SAMPLE:
          case GROUP_CONCAT:
          case BOUND:
          case COALESCE:
          case IF:
          case BNODE:
          case IRI:
          case URI:
          case STR:
          case STRLANG:
          case STRDT:
          case DTYPE:
          case LANG:
          case LANGMATCHES:
          case IS_URI:
          case IS_IRI:
          case IS_BLANK:
          case IS_LITERAL:
          case IS_NUMERIC:
          case REGEX:
          case SAME_TERM:
          case RAND:
          case ABS:
          case CEIL:
          case FLOOR:
          case ROUND:
          case CONCAT:
          case SUBSTR:
          case STRLEN:
          case REPLACE:
          case UCASE:
          case LCASE:
          case ENCODE_FOR_URI:
          case CONTAINS:
          case STRSTARTS:
          case STRENDS:
          case STRBEFORE:
          case STRAFTER:
          case YEAR:
          case MONTH:
          case DAY:
          case HOURS:
          case MINUTES:
          case SECONDS:
          case TIMEZONE:
          case TZ:
          case NOW:
          case UUID:
          case STRUUID:
          case MD5:
          case SHA1:
          case SHA256:
          case SHA384:
          case SHA512:
          case LPAREN:
            expr = Constraint();
            break;
          case VAR1:
          case VAR2:
            v = Var();
            break;
          default:
            jj_la1[30] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    if (v == null) getQuery().addOrderBy(expr, direction);
    else getQuery().addOrderBy(v, direction);
  }

  public final void LimitOffsetClauses() throws ParseException {
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LIMIT:
        LimitClause();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case OFFSET:
            OffsetClause();
            break;
          default:
            jj_la1[32] = jj_gen;
            ;
        }
        break;
      case OFFSET:
        OffsetClause();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case LIMIT:
            LimitClause();
            break;
          default:
            jj_la1[33] = jj_gen;
            ;
        }
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  public final void LimitClause() throws ParseException {
    Token t;
    jj_consume_token(LIMIT);
    t = jj_consume_token(INTEGER);
    getQuery().setLimit(integerValue(t.image));
  }

  public final void OffsetClause() throws ParseException {
    Token t;
    jj_consume_token(OFFSET);
    t = jj_consume_token(INTEGER);
    getQuery().setOffset(integerValue(t.image));
  }

  public final void ValuesClause() throws ParseException {
    Token t;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case VALUES:
        t = jj_consume_token(VALUES);
        startValuesClause(t.beginLine, t.beginColumn);
        DataBlock();
        finishValuesClause(t.beginLine, t.beginColumn);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
    }
  }

  public final void Update() throws ParseException {
    Prologue();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case INSERT:
      case DELETE:
      case INSERT_DATA:
      case DELETE_DATA:
      case DELETE_WHERE:
      case LOAD:
      case CLEAR:
      case CREATE:
      case ADD:
      case MOVE:
      case COPY:
      case DROP:
      case WITH:
        // Update1();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON:
            jj_consume_token(SEMICOLON);
            Update();
            break;
          default:
            jj_la1[36] = jj_gen;
            ;
        }
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
    }
  }

  //  final public void Update1() throws ParseException {
  //                   Update up = null ;
  //    startUpdateOperation() ;
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case LOAD:
  //      up = Load();
  //      break;
  //    case CLEAR:
  //      up = Clear();
  //      break;
  //    case DROP:
  //      up = Drop();
  //      break;
  //    case ADD:
  //      up = Add();
  //      break;
  //    case MOVE:
  //      up = Move();
  //      break;
  //    case COPY:
  //      up = Copy();
  //      break;
  //    case CREATE:
  //      up = Create();
  //      break;
  //    case DELETE_WHERE:
  //      up = DeleteWhere();
  //      break;
  //    case INSERT:
  //    case DELETE:
  //    case WITH:
  //      up = Modify();
  //      break;
  //    case INSERT_DATA:
  //      InsertData();
  //      break;
  //    case DELETE_DATA:
  //      DeleteData();
  //      break;
  //    default:
  //      jj_la1[38] = jj_gen;
  //      jj_consume_token(-1);
  //      throw new ParseException();
  //    }
  //    if (null != up) emitUpdate(up) ;
  //    finishUpdateOperation() ;
  //  }

  //  final public Update Load() throws ParseException {
  //                  String url ; Node dest = null ; boolean silent = false ;
  //    jj_consume_token(LOAD);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case SILENT:
  //      jj_consume_token(SILENT);
  //                       silent = true ;
  //      break;
  //    default:
  //      jj_la1[39] = jj_gen;
  //      ;
  //    }
  //    url = iri();
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case INTO:
  //      jj_consume_token(INTO);
  //      dest = GraphRef();
  //      break;
  //    default:
  //      jj_la1[40] = jj_gen;
  //      ;
  //    }
  //      {if (true) return new UpdateLoad(url, dest, silent) ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public Update Clear() throws ParseException {
  //                   boolean silent = false ; Target target ;
  //    jj_consume_token(CLEAR);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case SILENT:
  //      jj_consume_token(SILENT);
  //                       silent = true ;
  //      break;
  //    default:
  //      jj_la1[41] = jj_gen;
  //      ;
  //    }
  //    target = GraphRefAll();
  //     {if (true) return new UpdateClear(target, silent) ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public Update Drop() throws ParseException {
  //                  boolean silent = false ; Target target ;
  //    jj_consume_token(DROP);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case SILENT:
  //      jj_consume_token(SILENT);
  //                      silent = true ;
  //      break;
  //    default:
  //      jj_la1[42] = jj_gen;
  //      ;
  //    }
  //    target = GraphRefAll();
  //     {if (true) return new UpdateDrop(target, silent) ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public Update Create() throws ParseException {
  //                    Node iri ; boolean silent = false ;
  //    jj_consume_token(CREATE);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case SILENT:
  //      jj_consume_token(SILENT);
  //                        silent=true ;
  //      break;
  //    default:
  //      jj_la1[43] = jj_gen;
  //      ;
  //    }
  //    iri = GraphRef();
  //     {if (true) return new UpdateCreate(iri, silent) ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public Update Add() throws ParseException {
  //                 Target src ; Target dest ; boolean silent = false ;
  //    jj_consume_token(ADD);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case SILENT:
  //      jj_consume_token(SILENT);
  //                    silent=true ;
  //      break;
  //    default:
  //      jj_la1[44] = jj_gen;
  //      ;
  //    }
  //    src = GraphOrDefault();
  //    jj_consume_token(TO);
  //    dest = GraphOrDefault();
  //    {if (true) return new UpdateAdd(src, dest, silent) ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public Update Move() throws ParseException {
  //                  Target src ; Target dest ; boolean silent = false ;
  //    jj_consume_token(MOVE);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case SILENT:
  //      jj_consume_token(SILENT);
  //                     silent=true ;
  //      break;
  //    default:
  //      jj_la1[45] = jj_gen;
  //      ;
  //    }
  //    src = GraphOrDefault();
  //    jj_consume_token(TO);
  //    dest = GraphOrDefault();
  //    {if (true) return new UpdateMove(src, dest, silent) ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public Update Copy() throws ParseException {
  //                  Target src ; Target dest ; boolean silent = false ;
  //    jj_consume_token(COPY);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case SILENT:
  //      jj_consume_token(SILENT);
  //                     silent=true ;
  //      break;
  //    default:
  //      jj_la1[46] = jj_gen;
  //      ;
  //    }
  //    src = GraphOrDefault();
  //    jj_consume_token(TO);
  //    dest = GraphOrDefault();
  //    {if (true) return new UpdateCopy(src, dest, silent) ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public void InsertData() throws ParseException {
  //                      QuadDataAccSink qd = createInsertDataSink() ; Token t ;
  //    t = jj_consume_token(INSERT_DATA);
  //    int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null;
  //    startDataInsert(qd, beginLine, beginColumn) ;
  //    QuadData(qd);
  //    finishDataInsert(qd, beginLine, beginColumn) ;
  //    qd.close() ;
  //  }
  //
  //  final public void DeleteData() throws ParseException {
  //                      QuadDataAccSink qd = createDeleteDataSink() ; Token t ;
  //    t = jj_consume_token(DELETE_DATA);
  //    int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null;
  //    startDataDelete(qd, beginLine, beginColumn) ;
  //    QuadData(qd);
  //    finishDataDelete(qd, beginLine, beginColumn) ;
  //    qd.close() ;
  //  }
  //
  //  final public Update DeleteWhere() throws ParseException {
  //                         QuadAcc qp = new QuadAcc() ; Token t ;
  //    t = jj_consume_token(DELETE_WHERE);
  //    int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null;
  //    startDeleteTemplate(qp, beginLine, beginColumn) ;
  //    QuadPattern(qp);
  //    finishDeleteTemplate(qp, beginLine, beginColumn) ;
  //    {if (true) return new UpdateDeleteWhere(qp) ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public Update Modify() throws ParseException {
  //                    Element el ; String iri = null ;
  //                    UpdateModify up = new UpdateModify() ;
  //    startModifyUpdate() ;
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case WITH:
  //      jj_consume_token(WITH);
  //      iri = iri();
  //                         Node n = createNode(iri) ; up.setWithIRI(n) ;
  //      break;
  //    default:
  //      jj_la1[47] = jj_gen;
  //      ;
  //    }
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case DELETE:
  //      DeleteClause(up);
  //      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //      case INSERT:
  //        InsertClause(up);
  //        break;
  //      default:
  //        jj_la1[48] = jj_gen;
  //        ;
  //      }
  //      break;
  //    case INSERT:
  //      InsertClause(up);
  //      break;
  //    default:
  //      jj_la1[49] = jj_gen;
  //      jj_consume_token(-1);
  //      throw new ParseException();
  //    }
  //    label_12:
  //    while (true) {
  //      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //      case USING:
  //        ;
  //        break;
  //      default:
  //        jj_la1[50] = jj_gen;
  //        break label_12;
  //      }
  //      UsingClause(up);
  //    }
  //    jj_consume_token(WHERE);
  //    startWherePattern() ;
  //    el = GroupGraphPattern();
  //                             up.setElement(el) ;
  //    finishWherePattern() ;
  //    finishModifyUpdate() ;
  //    {if (true) return up ;}
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public void DeleteClause(UpdateModify up) throws ParseException {
  //                                       QuadAcc qp = up.getDeleteAcc() ; Token t ;
  //    t = jj_consume_token(DELETE);
  //     int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null;
  //     startDeleteTemplate(qp, beginLine, beginColumn) ;
  //    QuadPattern(qp);
  //     finishDeleteTemplate(qp, beginLine, beginColumn) ;
  //     up.setHasDeleteClause(true) ;
  //  }
  //
  //  final public void InsertClause(UpdateModify up) throws ParseException {
  //                                       QuadAcc qp = up.getInsertAcc() ; Token t ;
  //    t = jj_consume_token(INSERT);
  //     int beginLine = t.beginLine; int beginColumn = t.beginColumn; t = null;
  //     startInsertTemplate(qp, beginLine, beginColumn) ;
  //    QuadPattern(qp);
  //     finishInsertTemplate(qp, beginLine, beginColumn) ;
  //     up.setHasInsertClause(true) ;
  //  }
  //
  //  final public void UsingClause(UpdateWithUsing update) throws ParseException {
  //                                             String iri ; Node n ;
  //    jj_consume_token(USING);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case IRIref:
  //    case PNAME_NS:
  //    case PNAME_LN:
  //      iri = iri();
  //      n = createNode(iri) ; update.addUsing(n) ;
  //      break;
  //    case NAMED:
  //      jj_consume_token(NAMED);
  //      iri = iri();
  //      n = createNode(iri) ; update.addUsingNamed(n) ;
  //      break;
  //    default:
  //      jj_la1[51] = jj_gen;
  //      jj_consume_token(-1);
  //      throw new ParseException();
  //    }
  //  }
  //
  //  final public Target GraphOrDefault() throws ParseException {
  //                            String iri ;
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case DFT:
  //      jj_consume_token(DFT);
  //            {if (true) return Target.DEFAULT ;}
  //      break;
  //    case IRIref:
  //    case PNAME_NS:
  //    case PNAME_LN:
  //    case GRAPH:
  //      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //      case GRAPH:
  //        jj_consume_token(GRAPH);
  //        break;
  //      default:
  //        jj_la1[52] = jj_gen;
  //        ;
  //      }
  //      iri = iri();
  //       {if (true) return Target.create(createNode(iri)) ;}
  //      break;
  //    default:
  //      jj_la1[53] = jj_gen;
  //      jj_consume_token(-1);
  //      throw new ParseException();
  //    }
  //    throw new Error("Missing return statement in function");
  //  }
  //
  //  final public Node GraphRef() throws ParseException {
  //                    String iri ;
  //    jj_consume_token(GRAPH);
  //    iri = iri();
  //      {if (true) return createNode(iri) ;}
  //    throw new Error("Missing return statement in function");
  //  }

  //  final public Target GraphRefAll() throws ParseException {
  //                         Node iri ;
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case GRAPH:
  //      iri = GraphRef();
  //       {if (true) return Target.create(iri) ;}
  //      break;
  //    case DFT:
  //      jj_consume_token(DFT);
  //             {if (true) return Target.DEFAULT ;}
  //      break;
  //    case NAMED:
  //      jj_consume_token(NAMED);
  //               {if (true) return Target.NAMED ;}
  //      break;
  //    case ALL:
  //      jj_consume_token(ALL);
  //             {if (true) return Target.ALL ;}
  //      break;
  //    default:
  //      jj_la1[54] = jj_gen;
  //      jj_consume_token(-1);
  //      throw new ParseException();
  //    }
  //    throw new Error("Missing return statement in function");
  //  }

  //  final public void QuadPattern(QuadAcc org.rdf4led.common.data.incremental.acc) throws ParseException {
  //    jj_consume_token(LBRACE);
  //    Quads(org.rdf4led.common.data.incremental.acc);
  //    jj_consume_token(RBRACE);
  //  }

  //  final public void QuadData(QuadDataAccSink org.rdf4led.common.data.incremental.acc) throws ParseException {
  //    jj_consume_token(LBRACE);
  //    Quads(org.rdf4led.common.data.incremental.acc);
  //    jj_consume_token(RBRACE);
  //  }

  //  final public void Quads(QuadAccSink org.rdf4led.common.data.incremental.acc) throws ParseException {
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case IRIref:
  //    case PNAME_NS:
  //    case PNAME_LN:
  //    case BLANK_NODE_LABEL:
  //    case VAR1:
  //    case VAR2:
  //    case TRUE:
  //    case FALSE:
  //    case INTEGER:
  //    case DECIMAL:
  //    case DOUBLE:
  //    case INTEGER_POSITIVE:
  //    case DECIMAL_POSITIVE:
  //    case DOUBLE_POSITIVE:
  //    case INTEGER_NEGATIVE:
  //    case DECIMAL_NEGATIVE:
  //    case DOUBLE_NEGATIVE:
  //    case STRING_LITERAL1:
  //    case STRING_LITERAL2:
  //    case STRING_LITERAL_LONG1:
  //    case STRING_LITERAL_LONG2:
  //    case LPAREN:
  //    case NIL:
  //    case LBRACKET:
  //    case ANON:
  //      TriplesTemplate(org.rdf4led.common.data.incremental.acc);
  //      break;
  //    default:
  //      jj_la1[55] = jj_gen;
  //      ;
  //    }
  //    label_13:
  //    while (true) {
  //      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //      case GRAPH:
  //        ;
  //        break;
  //      default:
  //        jj_la1[56] = jj_gen;
  //        break label_13;
  //      }
  //      QuadsNotTriples(org.rdf4led.common.data.incremental.acc);
  //      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //      case DOT:
  //        jj_consume_token(DOT);
  //        break;
  //      default:
  //        jj_la1[57] = jj_gen;
  //        ;
  //      }
  //      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //      case IRIref:
  //      case PNAME_NS:
  //      case PNAME_LN:
  //      case BLANK_NODE_LABEL:
  //      case VAR1:
  //      case VAR2:
  //      case TRUE:
  //      case FALSE:
  //      case INTEGER:
  //      case DECIMAL:
  //      case DOUBLE:
  //      case INTEGER_POSITIVE:
  //      case DECIMAL_POSITIVE:
  //      case DOUBLE_POSITIVE:
  //      case INTEGER_NEGATIVE:
  //      case DECIMAL_NEGATIVE:
  //      case DOUBLE_NEGATIVE:
  //      case STRING_LITERAL1:
  //      case STRING_LITERAL2:
  //      case STRING_LITERAL_LONG1:
  //      case STRING_LITERAL_LONG2:
  //      case LPAREN:
  //      case NIL:
  //      case LBRACKET:
  //      case ANON:
  //        TriplesTemplate(org.rdf4led.common.data.incremental.acc);
  //        break;
  //      default:
  //        jj_la1[58] = jj_gen;
  //        ;
  //      }
  //    }
  //  }

  //  final public void QuadsNotTriples(QuadAccSink org.rdf4led.common.data.incremental.acc) throws ParseException {
  //                                         Node gn ; Node prev = org.rdf4led.common.data.incremental.acc.getGraph() ;
  //    jj_consume_token(GRAPH);
  //    gn = VarOrIri();
  //      setAccGraph(org.rdf4led.common.data.incremental.acc, gn) ;
  //    jj_consume_token(LBRACE);
  //    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
  //    case IRIref:
  //    case PNAME_NS:
  //    case PNAME_LN:
  //    case BLANK_NODE_LABEL:
  //    case VAR1:
  //    case VAR2:
  //    case TRUE:
  //    case FALSE:
  //    case INTEGER:
  //    case DECIMAL:
  //    case DOUBLE:
  //    case INTEGER_POSITIVE:
  //    case DECIMAL_POSITIVE:
  //    case DOUBLE_POSITIVE:
  //    case INTEGER_NEGATIVE:
  //    case DECIMAL_NEGATIVE:
  //    case DOUBLE_NEGATIVE:
  //    case STRING_LITERAL1:
  //    case STRING_LITERAL2:
  //    case STRING_LITERAL_LONG1:
  //    case STRING_LITERAL_LONG2:
  //    case LPAREN:
  //    case NIL:
  //    case LBRACKET:
  //    case ANON:
  //      TriplesTemplate(org.rdf4led.common.data.incremental.acc);
  //      break;
  //    default:
  //      jj_la1[59] = jj_gen;
  //      ;
  //    }
  //    jj_consume_token(RBRACE);
  //      setAccGraph(org.rdf4led.common.data.incremental.acc, prev) ;
  //  }

  public final void TriplesTemplate(TripleCollector<Node> acc) throws ParseException {
    TriplesSameSubject(acc);
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case BLANK_NODE_LABEL:
          case VAR1:
          case VAR2:
          case TRUE:
          case FALSE:
          case INTEGER:
          case DECIMAL:
          case DOUBLE:
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case STRING_LITERAL1:
          case STRING_LITERAL2:
          case STRING_LITERAL_LONG1:
          case STRING_LITERAL_LONG2:
          case LPAREN:
          case NIL:
          case LBRACKET:
          case ANON:
            TriplesTemplate(acc);
            break;
          default:
            jj_la1[60] = jj_gen;
            ;
        }
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
    }
  }

  public final Element<Node> GroupGraphPattern() throws ParseException {
    Element<Node> el = null;
    Token t;
    t = jj_consume_token(LBRACE);
    int beginLine = t.beginLine;
    int beginColumn = t.beginColumn;
    t = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SELECT:
        startSubSelect(beginLine, beginColumn);
        SubSelect();
        Query<Node> q = endSubSelect(beginLine, beginColumn);
        el = new ElementSubQuery<Node>(q);
        break;
      default:
        jj_la1[62] = jj_gen;
        el = GroupGraphPatternSub();
    }
    jj_consume_token(RBRACE);
    {
      if (true) return el;
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> GroupGraphPatternSub() throws ParseException {
    Element<Node> el = null;
    ElementGroup<Node> elg = new ElementGroup<Node>();
    startGroup(elg);
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case TRUE:
      case FALSE:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case LPAREN:
      case NIL:
      case LBRACKET:
      case ANON:
        startTriplesBlock();
        el = TriplesBlock(null);
        endTriplesBlock();
        elg.addElement(el);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
    }
    label_14:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case VALUES:
        case GRAPH:
        case OPTIONAL:
        case MINUS_P:
        case BIND:
        case SERVICE:
        case FILTER:
        case LBRACE:;
          break;
        default:
          jj_la1[64] = jj_gen;
          break label_14;
      }
      el = GraphPatternNotTriples();
      elg.addElement(el);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
          break;
        default:
          jj_la1[65] = jj_gen;
          ;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case LPAREN:
        case NIL:
        case LBRACKET:
        case ANON:
          startTriplesBlock();
          el = TriplesBlock(null);
          endTriplesBlock();
          elg.addElement(el);
          break;
        default:
          jj_la1[66] = jj_gen;
          ;
      }
    }
    endGroup(elg);
    {
      if (true) return elg;
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> TriplesBlock(ElementPathBlock<Node> acc) throws ParseException {
    if (acc == null) acc = createElementPathBlock();
    TriplesSameSubjectPath(acc);
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case BLANK_NODE_LABEL:
          case VAR1:
          case VAR2:
          case TRUE:
          case FALSE:
          case INTEGER:
          case DECIMAL:
          case DOUBLE:
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case STRING_LITERAL1:
          case STRING_LITERAL2:
          case STRING_LITERAL_LONG1:
          case STRING_LITERAL_LONG2:
          case LPAREN:
          case NIL:
          case LBRACKET:
          case ANON:
            TriplesBlock(acc);
            break;
          default:
            jj_la1[67] = jj_gen;
            ;
        }
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
    }
    {
      if (true) return acc;
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> GraphPatternNotTriples() throws ParseException {
    Element<Node> el = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LBRACE:
        el = GroupOrUnionGraphPattern();
        break;
      case OPTIONAL:
        el = OptionalGraphPattern();
        break;
      case MINUS_P:
        el = MinusGraphPattern();
        break;
      case GRAPH:
        el = GraphGraphPattern();
        break;
      case SERVICE:
        el = ServiceGraphPattern();
        break;
      case FILTER:
        el = Filter();
        break;
      case BIND:
        el = Bind();
        break;
      case VALUES:
        el = InlineData();
        break;
      default:
        jj_la1[69] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return el;
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> OptionalGraphPattern() throws ParseException {
    Element<Node> el;
    jj_consume_token(OPTIONAL);
    el = GroupGraphPattern();
    {
      if (true) return new ElementOptional<Node>(el);
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> GraphGraphPattern() throws ParseException {
    Element<Node> el;
    Node n;
    jj_consume_token(GRAPH);
    n = VarOrIri();
    el = GroupGraphPattern();
    {
      if (true) return new ElementNamedGraph<Node>(n, el);
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> ServiceGraphPattern() throws ParseException {
    Element<Node> el;
    Node n;
    boolean silent = false;
    jj_consume_token(SERVICE);
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case SILENT:
        jj_consume_token(SILENT);
        silent = true;
        break;
      default:
        jj_la1[70] = jj_gen;
        ;
    }
    n = VarOrIri();
    el = GroupGraphPattern();
    {
      if (true) return new ElementService<Node>(n, el, silent);
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> Bind() throws ParseException {
    Node v;
    Expr<Node> expr;
    jj_consume_token(BIND);
    jj_consume_token(LPAREN);
    expr = Expression();
    jj_consume_token(AS);
    v = Var();
    jj_consume_token(RPAREN);
    {
      if (true) return new ElementBind<Node>(v, expr);
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> InlineData() throws ParseException {
    ElementData<Node> el;
    Token t;
    t = jj_consume_token(VALUES);
    int beginLine = t.beginLine;
    int beginColumn = t.beginColumn;
    t = null;
    el = new ElementData();
    startInlineData(el.getVars(), el.getRows(), beginLine, beginColumn);
    DataBlock();
    finishInlineData(beginLine, beginColumn);
    {
      if (true) return el;
    }
    throw new Error("Missing return statement in function");
  }

  public final void DataBlock() throws ParseException {
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case VAR1:
      case VAR2:
        InlineDataOneVar();
        break;
      case LPAREN:
      case NIL:
        InlineDataFull();
        break;
      default:
        jj_la1[71] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  public final void InlineDataOneVar() throws ParseException {
    Node v;
    Node n;
    Token t;
    v = Var();
    emitDataBlockVariable(v);
    t = jj_consume_token(LBRACE);
    label_15:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case UNDEF:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:;
          break;
        default:
          jj_la1[72] = jj_gen;
          break label_15;
      }
      n = DataBlockValue();
      startDataBlockValueRow(-1, -1);
      emitDataBlockValue(n, -1, -1);
      finishDataBlockValueRow(-1, -1);
    }
    t = jj_consume_token(RBRACE);
  }

  public final void InlineDataFull() throws ParseException {
    Node v;
    Node n;
    Token t;
    int beginLine;
    int beginColumn;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case NIL:
        jj_consume_token(NIL);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        label_16:
        while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case VAR1:
            case VAR2:;
              break;
            default:
              jj_la1[73] = jj_gen;
              break label_16;
          }
          v = Var();
          emitDataBlockVariable(v);
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    jj_consume_token(LBRACE);
    label_17:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case LPAREN:
        case NIL:;
          break;
        default:
          jj_la1[75] = jj_gen;
          break label_17;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case LPAREN:
          t = jj_consume_token(LPAREN);
          beginLine = t.beginLine;
          beginColumn = t.beginColumn;
          t = null;
          startDataBlockValueRow(beginLine, beginColumn);
          label_18:
          while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case IRIref:
              case PNAME_NS:
              case PNAME_LN:
              case UNDEF:
              case TRUE:
              case FALSE:
              case INTEGER:
              case DECIMAL:
              case DOUBLE:
              case INTEGER_POSITIVE:
              case DECIMAL_POSITIVE:
              case DOUBLE_POSITIVE:
              case INTEGER_NEGATIVE:
              case DECIMAL_NEGATIVE:
              case DOUBLE_NEGATIVE:
              case STRING_LITERAL1:
              case STRING_LITERAL2:
              case STRING_LITERAL_LONG1:
              case STRING_LITERAL_LONG2:;
                break;
              default:
                jj_la1[76] = jj_gen;
                break label_18;
            }
            n = DataBlockValue();
            emitDataBlockValue(n, beginLine, beginColumn);
          }
          t = jj_consume_token(RPAREN);
          beginLine = t.beginLine;
          beginColumn = t.beginColumn;
          t = null;
          finishDataBlockValueRow(beginLine, beginColumn);
          break;
        case NIL:
          t = jj_consume_token(NIL);
          beginLine = t.beginLine;
          beginColumn = t.beginColumn;
          t = null;
          startDataBlockValueRow(beginLine, beginColumn);
          finishDataBlockValueRow(beginLine, beginColumn);
          break;
        default:
          jj_la1[77] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
  }

  public final Node DataBlockValue() throws ParseException {
    Node n;
    String iri;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        iri = iri();
        {
          if (true) return createNode(iri);
        }
        break;
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
        n = RDFLiteral();
        {
          if (true) return n;
        }
        break;
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
        n = NumericLiteral();
        {
          if (true) return n;
        }
        break;
      case TRUE:
      case FALSE:
        n = BooleanLiteral();
        {
          if (true) return n;
        }
        break;
      case UNDEF:
        jj_consume_token(UNDEF);
        {
          if (true) return null;
        }
        break;
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> MinusGraphPattern() throws ParseException {
    Element<Node> el;
    jj_consume_token(MINUS_P);
    el = GroupGraphPattern();
    {
      if (true) return new ElementMinus<Node>(el);
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> GroupOrUnionGraphPattern() throws ParseException {
    Element<Node> el = null;
    ElementUnion<Node> el2 = null;
    el = GroupGraphPattern();
    label_19:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case UNION:;
          break;
        default:
          jj_la1[79] = jj_gen;
          break label_19;
      }
      jj_consume_token(UNION);
      if (el2 == null) {
        el2 = new ElementUnion();
        el2.addElement(el);
      }
      el = GroupGraphPattern();
      el2.addElement(el);
    }
    {
      if (true) return (el2 == null) ? el : el2;
    }
    throw new Error("Missing return statement in function");
  }

  public final Element<Node> Filter() throws ParseException {
    Expr<Node> c;
    jj_consume_token(FILTER);
    c = Constraint();
    {
      if (true) return new ElementFilter<Node>(c);
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> Constraint() throws ParseException {
    Expr<Node> c;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LPAREN:
        c = BrackettedExpression();
        break;
      case EXISTS:
      case NOT:
      case COUNT:
      case MIN:
      case MAX:
      case SUM:
      case AVG:
      case SAMPLE:
      case GROUP_CONCAT:
      case BOUND:
      case COALESCE:
      case IF:
      case BNODE:
      case IRI:
      case URI:
      case STR:
      case STRLANG:
      case STRDT:
      case DTYPE:
      case LANG:
      case LANGMATCHES:
      case IS_URI:
      case IS_IRI:
      case IS_BLANK:
      case IS_LITERAL:
      case IS_NUMERIC:
      case REGEX:
      case SAME_TERM:
      case RAND:
      case ABS:
      case CEIL:
      case FLOOR:
      case ROUND:
      case CONCAT:
      case SUBSTR:
      case STRLEN:
      case REPLACE:
      case UCASE:
      case LCASE:
      case ENCODE_FOR_URI:
      case CONTAINS:
      case STRSTARTS:
      case STRENDS:
      case STRBEFORE:
      case STRAFTER:
      case YEAR:
      case MONTH:
      case DAY:
      case HOURS:
      case MINUTES:
      case SECONDS:
      case TIMEZONE:
      case TZ:
      case NOW:
      case UUID:
      case STRUUID:
      case MD5:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
        c = BuiltInCall();
        break;
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        c = FunctionCall();
        break;
      default:
        jj_la1[80] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return c;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> FunctionCall() throws ParseException {
    String fname;
    ExprList<Node> a;
    fname = iri();
    a = ArgList();
    {
      if (true) return create_E_Function(fname, a);
    }
    throw new Error("Missing return statement in function");
  }

  public final ExprList<Node> ArgList() throws ParseException {
    Expr<Node> expr;
    boolean distinct = false;
    ExprList<Node> args = new ExprList<Node>();
    Token t;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case NIL:
        jj_consume_token(NIL);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            t = jj_consume_token(DISTINCT);
            distinct = true;
            int beginLine = t.beginLine;
            int beginColumn = t.beginColumn;
            t = null;
            if (!allowAggregatesInExpressions)
              throwParseException(
                  "Aggregate expression not legal at this point", beginLine, beginColumn);
            break;
          default:
            jj_la1[81] = jj_gen;
            ;
        }
        expr = Expression();
        args.add(expr);
        label_20:
        while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case COMMA:;
              break;
            default:
              jj_la1[82] = jj_gen;
              break label_20;
          }
          jj_consume_token(COMMA);
          expr = Expression();
          args.add(expr);
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[83] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return args;
    }
    throw new Error("Missing return statement in function");
  }

  public final ExprList<Node> ExpressionList() throws ParseException {
    Expr<Node> expr = null;
    ExprList<Node> args = new ExprList<Node>();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case NIL:
        jj_consume_token(NIL);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        expr = Expression();
        args.add(expr);
        label_21:
        while (true) {
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case COMMA:;
              break;
            default:
              jj_la1[84] = jj_gen;
              break label_21;
          }
          jj_consume_token(COMMA);
          expr = Expression();
          args.add(expr);
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return args;
    }
    throw new Error("Missing return statement in function");
  }

  public final Template<Node> ConstructTemplate() throws ParseException {
    TripleCollectorBGP<Node> acc = new TripleCollectorBGP<Node>();
    Template<Node> t = new Template<Node>(acc.getBGP());
    setInConstructTemplate(true);
    jj_consume_token(LBRACE);
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case TRUE:
      case FALSE:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case LPAREN:
      case NIL:
      case LBRACKET:
      case ANON:
        ConstructTriples(acc);
        break;
      default:
        jj_la1[86] = jj_gen;
        ;
    }
    jj_consume_token(RBRACE);
    setInConstructTemplate(false);
    {
      if (true) return t;
    }
    throw new Error("Missing return statement in function");
  }

  public final void ConstructTriples(TripleCollector<Node> acc) throws ParseException {
    TriplesSameSubject(acc);
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case BLANK_NODE_LABEL:
          case VAR1:
          case VAR2:
          case TRUE:
          case FALSE:
          case INTEGER:
          case DECIMAL:
          case DOUBLE:
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case STRING_LITERAL1:
          case STRING_LITERAL2:
          case STRING_LITERAL_LONG1:
          case STRING_LITERAL_LONG2:
          case LPAREN:
          case NIL:
          case LBRACKET:
          case ANON:
            ConstructTriples(acc);
            break;
          default:
            jj_la1[87] = jj_gen;
            ;
        }
        break;
      default:
        jj_la1[88] = jj_gen;
        ;
    }
  }

  public final void TriplesSameSubject(TripleCollector<Node> acc) throws ParseException {
    Node s;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case TRUE:
      case FALSE:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        s = VarOrTerm();
        PropertyListNotEmpty(s, acc);
        break;
      case LPAREN:
      case LBRACKET:
        ElementPathBlock<Node> tempAcc = createElementPathBlock();
        s = TriplesNode(tempAcc);
        PropertyList(s, tempAcc);
        insert(acc, tempAcc);
        break;
      default:
        jj_la1[89] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  public final void PropertyList(Node s, TripleCollector<Node> acc) throws ParseException {
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case VAR1:
      case VAR2:
      case KW_A:
        PropertyListNotEmpty(s, acc);
        break;
      default:
        jj_la1[90] = jj_gen;
        ;
    }
  }

  public final void PropertyListNotEmpty(Node s, TripleCollector<Node> acc) throws ParseException {
    Node p = null;
    p = Verb();
    ObjectList(s, p, null, acc);
    label_22:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case SEMICOLON:;
          break;
        default:
          jj_la1[91] = jj_gen;
          break label_22;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case KW_A:
          p = Verb();
          ObjectList(s, p, null, acc);
          break;
        default:
          jj_la1[92] = jj_gen;
          ;
      }
    }
  }

  public final Node Verb() throws ParseException {
    Node p;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case VAR1:
      case VAR2:
        p = VarOrIri();
        break;
      case KW_A:
        jj_consume_token(KW_A);
        p = nRDFtype;
        break;
      default:
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return p;
    }
    throw new Error("Missing return statement in function");
  }

  public final void ObjectList(Node s, Node p, Path<Node> path, TripleCollector<Node> acc)
      throws ParseException {
    Node o;
    Object(s, p, path, acc);
    label_23:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case COMMA:;
          break;
        default:
          jj_la1[94] = jj_gen;
          break label_23;
      }
      jj_consume_token(COMMA);
      Object(s, p, path, acc);
    }
  }

  public final void Object(Node s, Node p, Path<Node> path, TripleCollector<Node> acc)
      throws ParseException {
    Node o;
    ElementPathBlock<Node> tempAcc = createElementPathBlock();
    int mark = tempAcc.mark();
    o = GraphNode(tempAcc);
    insert(tempAcc, mark, s, p, path, o);
    insert(acc, tempAcc);
  }

  public final void TriplesSameSubjectPath(TripleCollector<Node> acc) throws ParseException {
    Node s;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case TRUE:
      case FALSE:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        s = VarOrTerm();
        PropertyListPathNotEmpty(s, acc);
        break;
      case LPAREN:
      case LBRACKET:
        ElementPathBlock<Node> tempAcc = createElementPathBlock();
        s = TriplesNodePath(tempAcc);
        PropertyListPath(s, tempAcc);
        insert(acc, tempAcc);
        break;
      default:
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  public final void PropertyListPath(Node s, TripleCollector<Node> acc) throws ParseException {
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case VAR1:
      case VAR2:
      case KW_A:
      case LPAREN:
      case BANG:
      case CARAT:
        PropertyListPathNotEmpty(s, acc);
        break;
      default:
        jj_la1[96] = jj_gen;
        ;
    }
  }

  public final void PropertyListPathNotEmpty(Node s, TripleCollector<Node> acc)
      throws ParseException {
    Path<Node> path = null;
    Node p = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case KW_A:
      case LPAREN:
      case BANG:
      case CARAT:
        path = VerbPath();
        break;
      case VAR1:
      case VAR2:
        p = VerbSimple();
        break;
      default:
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    ObjectListPath(s, p, path, acc);
    label_24:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case SEMICOLON:;
          break;
        default:
          jj_la1[98] = jj_gen;
          break label_24;
      }
      jj_consume_token(SEMICOLON);
      path = null;
      p = null;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case KW_A:
        case LPAREN:
        case BANG:
        case CARAT:
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case IRIref:
            case PNAME_NS:
            case PNAME_LN:
            case KW_A:
            case LPAREN:
            case BANG:
            case CARAT:
              path = VerbPath();
              break;
            case VAR1:
            case VAR2:
              p = VerbSimple();
              break;
            default:
              jj_la1[99] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
          }
          ObjectListPath(s, p, path, acc);
          break;
        default:
          jj_la1[100] = jj_gen;
          ;
      }
    }
  }

  public final Path<Node> VerbPath() throws ParseException {
    Node p;
    Path<Node> path;
    path = Path();
    {
      if (true) return path;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node VerbSimple() throws ParseException {
    Node p;
    p = Var();
    {
      if (true) return p;
    }
    throw new Error("Missing return statement in function");
  }

  public final void ObjectListPath(Node s, Node p, Path<Node> path, TripleCollector<Node> acc)
      throws ParseException {
    Node o;
    ObjectPath(s, p, path, acc);
    label_25:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case COMMA:;
          break;
        default:
          jj_la1[101] = jj_gen;
          break label_25;
      }
      jj_consume_token(COMMA);
      ObjectPath(s, p, path, acc);
    }
  }

  public final void ObjectPath(Node s, Node p, Path<Node> path, TripleCollector<Node> acc)
      throws ParseException {
    Node o;
    ElementPathBlock<Node> tempAcc = createElementPathBlock();
    int mark = tempAcc.mark();
    o = GraphNodePath(tempAcc);
    insert(tempAcc, mark, s, p, path, o);
    insert(acc, tempAcc);
  }

  public final Path<Node> Path() throws ParseException {
    Path<Node> p;
    p = PathAlternative();
    {
      if (true) return p;
    }
    throw new Error("Missing return statement in function");
  }

  public final Path<Node> PathAlternative() throws ParseException {
    Path<Node> p1, p2;
    p1 = PathSequence();
    label_26:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case VBAR:;
          break;
        default:
          jj_la1[102] = jj_gen;
          break label_26;
      }
      jj_consume_token(VBAR);
      p2 = PathSequence();
      p1 = new P_Alt(p1, p2);
    }
    {
      if (true) return p1;
    }
    throw new Error("Missing return statement in function");
  }

  public final Path<Node> PathSequence() throws ParseException {
    Path<Node> p1, p2;
    p1 = PathEltOrInverse();
    label_27:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case SLASH:;
          break;
        default:
          jj_la1[103] = jj_gen;
          break label_27;
      }
      jj_consume_token(SLASH);
      p2 = PathEltOrInverse();
      p1 = new P_Seq(p1, p2);
    }
    {
      if (true) return p1;
    }
    throw new Error("Missing return statement in function");
  }

  public final Path PathElt() throws ParseException {
    String str;
    Node n;
    Path<Node> p;
    p = PathPrimary();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case PLUS:
      case STAR:
      case QMARK:
        p = PathMod(p);
        break;
      default:
        jj_la1[104] = jj_gen;
        ;
    }
    {
      if (true) return p;
    }
    throw new Error("Missing return statement in function");
  }

  public final Path PathEltOrInverse() throws ParseException {
    String str;
    Node n;
    Path<Node> p;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case KW_A:
      case LPAREN:
      case BANG:
        p = PathElt();
        break;
      case CARAT:
        jj_consume_token(CARAT);
        p = PathElt();
        p = new P_Inverse<Node>(p);
        break;
      default:
        jj_la1[105] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return p;
    }
    throw new Error("Missing return statement in function");
  }

  public final Path<Node> PathMod(Path p) throws ParseException {
    long i1;
    long i2;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case QMARK:
        jj_consume_token(QMARK);
        {
          if (true) return new P_ZeroOrOne<Node>(p);
        }
        ;
        break;
      case STAR:
        jj_consume_token(STAR);
        {
          if (true) return new P_ZeroOrMore1<Node>(p);
        }
        break;
      case PLUS:
        jj_consume_token(PLUS);
        {
          if (true) return new P_OneOrMore1<Node>(p);
        }
        break;
      default:
        jj_la1[106] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Path<Node> PathPrimary() throws ParseException {
    String str;
    Path<Node> p;
    Node n;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        str = iri();
        n = createNode(str);
        p = new P_Link<Node>(n);
        break;
      case KW_A:
        jj_consume_token(KW_A);
        p = new P_Link<Node>(nRDFtype);
        break;
      case BANG:
        jj_consume_token(BANG);
        p = PathNegatedPropertySet();
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        p = Path();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return p;
    }
    throw new Error("Missing return statement in function");
  }

  public final Path<Node> PathNegatedPropertySet() throws ParseException {
    P_Path0<Node> p;
    P_NegPropSet<Node> pNegSet;
    pNegSet = new P_NegPropSet<Node>();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case KW_A:
      case CARAT:
        p = PathOneInPropertySet();
        pNegSet.add(p);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case KW_A:
          case CARAT:
            p = PathOneInPropertySet();
            pNegSet.add(p);
            label_28:
            while (true) {
              switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case VBAR:;
                  break;
                default:
                  jj_la1[108] = jj_gen;
                  break label_28;
              }
              jj_consume_token(VBAR);
              p = PathOneInPropertySet();
              pNegSet.add(p);
            }
            break;
          default:
            jj_la1[109] = jj_gen;
            ;
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[110] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return pNegSet;
    }
    throw new Error("Missing return statement in function");
  }

  public final P_Path0<Node> PathOneInPropertySet() throws ParseException {
    String str;
    Node n;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        str = iri();
        n = createNode(str);
        {
          if (true) return new P_Link<Node>(n);
        }
        break;
      case KW_A:
        jj_consume_token(KW_A);
        {
          if (true) return new P_Link<Node>(nRDFtype);
        }
        break;
      case CARAT:
        jj_consume_token(CARAT);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
            str = iri();
            n = createNode(str);
            {
              if (true) return new P_ReverseLink<Node>(n);
            }
            break;
          case KW_A:
            jj_consume_token(KW_A);
            {
              if (true) return new P_ReverseLink<Node>(nRDFtype);
            }
            break;
          default:
            jj_la1[111] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        break;
      default:
        jj_la1[112] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final long Integer() throws ParseException {
    Token t;
    t = jj_consume_token(INTEGER);
    {
      if (true) return integerValue(t.image);
    }
    throw new Error("Missing return statement in function");
  }

  public final Node TriplesNode(TripleCollector<Node> acc) throws ParseException {
    Node n;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LPAREN:
        n = Collection(acc);
        {
          if (true) return n;
        }
        break;
      case LBRACKET:
        n = BlankNodePropertyList(acc);
        {
          if (true) return n;
        }
        break;
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Node BlankNodePropertyList(TripleCollector<Node> acc) throws ParseException {
    Token t;
    t = jj_consume_token(LBRACKET);
    Node n = createBNode(t.beginLine, t.beginColumn);
    PropertyListNotEmpty(n, acc);
    jj_consume_token(RBRACKET);
    {
      if (true) return n;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node TriplesNodePath(TripleCollector<Node> acc) throws ParseException {
    Node n;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LPAREN:
        n = CollectionPath(acc);
        {
          if (true) return n;
        }
        break;
      case LBRACKET:
        n = BlankNodePropertyListPath(acc);
        {
          if (true) return n;
        }
        break;
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Node BlankNodePropertyListPath(TripleCollector<Node> acc) throws ParseException {
    Token t;
    t = jj_consume_token(LBRACKET);
    Node n = createBNode(t.beginLine, t.beginColumn);
    PropertyListPathNotEmpty(n, acc);
    jj_consume_token(RBRACKET);
    {
      if (true) return n;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node Collection(TripleCollector<Node> acc) throws ParseException {
    Node listHead = nRDFnil;
    Node lastCell = null;
    int mark;
    Node n;
    Token t;
    t = jj_consume_token(LPAREN);
    int beginLine = t.beginLine;
    int beginColumn = t.beginColumn;
    t = null;
    label_29:
    while (true) {
      Node cell = createListNode(beginLine, beginColumn);
      if (listHead == nRDFnil) listHead = cell;
      if (lastCell != null) insert(acc, lastCell, nRDFrest, cell);
      mark = acc.mark();
      n = GraphNode(acc);
      insert(acc, mark, cell, nRDFfirst, n);
      lastCell = cell;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case LPAREN:
        case NIL:
        case LBRACKET:
        case ANON:;
          break;
        default:
          jj_la1[115] = jj_gen;
          break label_29;
      }
    }
    jj_consume_token(RPAREN);
    if (lastCell != null) insert(acc, lastCell, nRDFrest, nRDFnil);
    {
      if (true) return listHead;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node CollectionPath(TripleCollector<Node> acc) throws ParseException {
    Node listHead = nRDFnil;
    Node lastCell = null;
    int mark;
    Node n;
    Token t;
    t = jj_consume_token(LPAREN);
    int beginLine = t.beginLine;
    int beginColumn = t.beginColumn;
    t = null;
    label_30:
    while (true) {
      Node cell = createListNode(beginLine, beginColumn);
      if (listHead == nRDFnil) listHead = cell;
      if (lastCell != null) insert(acc, lastCell, nRDFrest, cell);
      mark = acc.mark();
      n = GraphNodePath(acc);
      insert(acc, mark, cell, nRDFfirst, n);
      lastCell = cell;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IRIref:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case TRUE:
        case FALSE:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case LPAREN:
        case NIL:
        case LBRACKET:
        case ANON:;
          break;
        default:
          jj_la1[116] = jj_gen;
          break label_30;
      }
    }
    jj_consume_token(RPAREN);
    if (lastCell != null) insert(acc, lastCell, nRDFrest, nRDFnil);
    {
      if (true) return listHead;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node GraphNode(TripleCollector<Node> acc) throws ParseException {
    Node n;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case TRUE:
      case FALSE:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        n = VarOrTerm();
        {
          if (true) return n;
        }
        break;
      case LPAREN:
      case LBRACKET:
        n = TriplesNode(acc);
        {
          if (true) return n;
        }
        break;
      default:
        jj_la1[117] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Node GraphNodePath(TripleCollector<Node> acc) throws ParseException {
    Node n;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case VAR1:
      case VAR2:
      case TRUE:
      case FALSE:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        n = VarOrTerm();
        {
          if (true) return n;
        }
        break;
      case LPAREN:
      case LBRACKET:
        n = TriplesNodePath(acc);
        {
          if (true) return n;
        }
        break;
      default:
        jj_la1[118] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Node VarOrTerm() throws ParseException {
    Node n = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case VAR1:
      case VAR2:
        n = Var();
        break;
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case BLANK_NODE_LABEL:
      case TRUE:
      case FALSE:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case NIL:
      case ANON:
        n = GraphTerm();
        break;
      default:
        jj_la1[119] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return n;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node VarOrIri() throws ParseException {
    Node n = null;
    String iri;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case VAR1:
      case VAR2:
        n = Var();
        break;
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        iri = iri();
        n = createNode(iri);
        break;
      default:
        jj_la1[120] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return n;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node VarOrBlankNodeOrIri() throws ParseException {
    Node n = null;
    String iri;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case VAR1:
      case VAR2:
        n = Var();
        break;
      case BLANK_NODE_LABEL:
      case ANON:
        n = BlankNode();
        break;
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        iri = iri();
        n = createNode(iri);
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return n;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node Var() throws ParseException {
    Token t;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case VAR1:
        t = jj_consume_token(VAR1);
        break;
      case VAR2:
        t = jj_consume_token(VAR2);
        break;
      default:
        jj_la1[122] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return createVariable(t.image, t.beginLine, t.beginColumn);
    }
    throw new Error("Missing return statement in function");
  }

  public final Node GraphTerm() throws ParseException {
    Node n;
    String iri;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        iri = iri();
        {
          if (true) return createNode(iri);
        }
        break;
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
        n = RDFLiteral();
        {
          if (true) return n;
        }
        break;
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
        n = NumericLiteral();
        {
          if (true) return n;
        }
        break;
      case TRUE:
      case FALSE:
        n = BooleanLiteral();
        {
          if (true) return n;
        }
        break;
      case BLANK_NODE_LABEL:
      case ANON:
        n = BlankNode();
        {
          if (true) return n;
        }
        break;
      case NIL:
        jj_consume_token(NIL);
        {
          if (true) return nRDFnil;
        }
        break;
      default:
        jj_la1[123] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> Expression() throws ParseException {
    Expr<Node> expr;
    expr = ConditionalOrExpression();
    {
      if (true) return expr;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> ConditionalOrExpression() throws ParseException {
    Expr<Node> expr1, expr2;
    expr1 = ConditionalAndExpression();
    label_31:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case SC_OR:;
          break;
        default:
          jj_la1[124] = jj_gen;
          break label_31;
      }
      jj_consume_token(SC_OR);
      expr2 = ConditionalAndExpression();
      expr1 = create_E_LogicalOr(expr1, expr2);
    }
    {
      if (true) return expr1;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> ConditionalAndExpression() throws ParseException {
    Expr<Node> expr1, expr2;
    expr1 = ValueLogical();
    label_32:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case SC_AND:;
          break;
        default:
          jj_la1[125] = jj_gen;
          break label_32;
      }
      jj_consume_token(SC_AND);
      expr2 = ValueLogical();
      expr1 = create_E_LogicalAnd(expr1, expr2);
    }
    {
      if (true) return expr1;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> ValueLogical() throws ParseException {
    Expr<Node> expr;
    expr = RelationalExpression();
    {
      if (true) return expr;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> RelationalExpression() throws ParseException {
    Expr<Node> expr1, expr2;
    ExprList<Node> a;
    expr1 = NumericExpression();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case NOT:
      case IN:
      case EQ:
      case NE:
      case GT:
      case LT:
      case LE:
      case GE:
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case EQ:
            jj_consume_token(EQ);
            expr2 = NumericExpression();
            expr1 = create_E_Equals(expr1, expr2);
            break;
          case NE:
            jj_consume_token(NE);
            expr2 = NumericExpression();
            expr1 = create_E_NotEquals(expr1, expr2);
            break;
          case LT:
            jj_consume_token(LT);
            expr2 = NumericExpression();
            expr1 = create_E_LessThan(expr1, expr2);
            break;
          case GT:
            jj_consume_token(GT);
            expr2 = NumericExpression();
            expr1 = create_E_GreaterThan(expr1, expr2);
            break;
          case LE:
            jj_consume_token(LE);
            expr2 = NumericExpression();
            expr1 = create_E_LessThanOrEqual(expr1, expr2);
            break;
          case GE:
            jj_consume_token(GE);
            expr2 = NumericExpression();
            expr1 = create_E_GreaterThanOrEqual(expr1, expr2);
            break;
          case IN:
            jj_consume_token(IN);
            a = ExpressionList();
            expr1 = create_E_OneOf(expr1, a);
            break;
          case NOT:
            jj_consume_token(NOT);
            jj_consume_token(IN);
            a = ExpressionList();
            expr1 = create_E_NotOneOf(expr1, a);
            break;
          default:
            jj_la1[126] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        break;
      default:
        jj_la1[127] = jj_gen;
        ;
    }
    {
      if (true) return expr1;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> NumericExpression() throws ParseException {
    Expr<Node> expr;
    expr = AdditiveExpression();
    {
      if (true) return expr;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> AdditiveExpression() throws ParseException {
    Expr<Node> expr1, expr2, expr3;
    boolean addition;
    Node n;
    expr1 = MultiplicativeExpression();
    label_33:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case PLUS:
        case MINUS:;
          break;
        default:
          jj_la1[128] = jj_gen;
          break label_33;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          expr2 = MultiplicativeExpression();
          expr1 = create_E_Add(expr1, expr2);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          expr2 = MultiplicativeExpression();
          expr1 = create_E_Subtract(expr1, expr2);
          break;
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
          switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE:
              n = NumericLiteralPositive();
              n = stripSign(n);

              expr2 = asExpr(n);

              addition = true;
              break;
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE:
              n = NumericLiteralNegative();
              n = stripSign(n);
              expr2 = asExpr(n);
              addition = false;
              break;
            default:
              jj_la1[129] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
          }
          label_34:
          while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case STAR:
              case SLASH:;
                break;
              default:
                jj_la1[130] = jj_gen;
                break label_34;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
              case STAR:
                jj_consume_token(STAR);
                expr3 = UnaryExpression();
                expr2 = create_E_Multiply(expr2, expr3);
                break;
              case SLASH:
                jj_consume_token(SLASH);
                expr3 = UnaryExpression();
                expr2 = create_E_Divide(expr2, expr3);
                break;
              default:
                jj_la1[131] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
          }
          if (addition) expr1 = create_E_Add(expr1, expr2);
          else expr1 = create_E_Subtract(expr1, expr2);
          break;
        default:
          jj_la1[132] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    }
    {
      if (true) return expr1;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> MultiplicativeExpression() throws ParseException {
    Expr<Node> expr1, expr2;
    expr1 = UnaryExpression();
    label_35:
    while (true) {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case STAR:
        case SLASH:;
          break;
        default:
          jj_la1[133] = jj_gen;
          break label_35;
      }
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case STAR:
          jj_consume_token(STAR);
          expr2 = UnaryExpression();
          expr1 = create_E_Multiply(expr1, expr2);
          break;
        case SLASH:
          jj_consume_token(SLASH);
          expr2 = UnaryExpression();
          expr1 = create_E_Divide(expr1, expr2);
          break;
        default:
          jj_la1[134] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
    }
    {
      if (true) return expr1;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> UnaryExpression() throws ParseException {
    Expr<Node> expr;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BANG:
        jj_consume_token(BANG);
        expr = PrimaryExpression();
        {
          if (true) return create_E_LogicalNot(expr);
        }
        break;
      case PLUS:
        jj_consume_token(PLUS);
        expr = PrimaryExpression();
        {
          if (true) return create_E_UnaryPlus(expr);
        }
        break;
      case MINUS:
        jj_consume_token(MINUS);
        expr = PrimaryExpression();
        {
          if (true) return create_E_UnaryMinus(expr);
        }
        break;
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
      case VAR1:
      case VAR2:
      case EXISTS:
      case NOT:
      case COUNT:
      case MIN:
      case MAX:
      case SUM:
      case AVG:
      case SAMPLE:
      case GROUP_CONCAT:
      case BOUND:
      case COALESCE:
      case IF:
      case BNODE:
      case IRI:
      case URI:
      case STR:
      case STRLANG:
      case STRDT:
      case DTYPE:
      case LANG:
      case LANGMATCHES:
      case IS_URI:
      case IS_IRI:
      case IS_BLANK:
      case IS_LITERAL:
      case IS_NUMERIC:
      case REGEX:
      case SAME_TERM:
      case RAND:
      case ABS:
      case CEIL:
      case FLOOR:
      case ROUND:
      case CONCAT:
      case SUBSTR:
      case STRLEN:
      case REPLACE:
      case UCASE:
      case LCASE:
      case ENCODE_FOR_URI:
      case CONTAINS:
      case STRSTARTS:
      case STRENDS:
      case STRBEFORE:
      case STRAFTER:
      case YEAR:
      case MONTH:
      case DAY:
      case HOURS:
      case MINUTES:
      case SECONDS:
      case TIMEZONE:
      case TZ:
      case NOW:
      case UUID:
      case STRUUID:
      case MD5:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
      case TRUE:
      case FALSE:
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
      case LPAREN:
        expr = PrimaryExpression();
        {
          if (true) return expr;
        }
        break;
      default:
        jj_la1[135] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr PrimaryExpression() throws ParseException {
    Expr<Node> expr;
    Node gn;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LPAREN:
        expr = BrackettedExpression();
        {
          if (true) return expr;
        }
        break;
      case EXISTS:
      case NOT:
      case COUNT:
      case MIN:
      case MAX:
      case SUM:
      case AVG:
      case SAMPLE:
      case GROUP_CONCAT:
      case BOUND:
      case COALESCE:
      case IF:
      case BNODE:
      case IRI:
      case URI:
      case STR:
      case STRLANG:
      case STRDT:
      case DTYPE:
      case LANG:
      case LANGMATCHES:
      case IS_URI:
      case IS_IRI:
      case IS_BLANK:
      case IS_LITERAL:
      case IS_NUMERIC:
      case REGEX:
      case SAME_TERM:
      case RAND:
      case ABS:
      case CEIL:
      case FLOOR:
      case ROUND:
      case CONCAT:
      case SUBSTR:
      case STRLEN:
      case REPLACE:
      case UCASE:
      case LCASE:
      case ENCODE_FOR_URI:
      case CONTAINS:
      case STRSTARTS:
      case STRENDS:
      case STRBEFORE:
      case STRAFTER:
      case YEAR:
      case MONTH:
      case DAY:
      case HOURS:
      case MINUTES:
      case SECONDS:
      case TIMEZONE:
      case TZ:
      case NOW:
      case UUID:
      case STRUUID:
      case MD5:
      case SHA1:
      case SHA256:
      case SHA384:
      case SHA512:
        expr = BuiltInCall();
        {
          if (true) return expr;
        }
        break;
      case IRIref:
      case PNAME_NS:
      case PNAME_LN:
        expr = iriOrFunction();
        {
          if (true) return expr;
        }
        break;
      case STRING_LITERAL1:
      case STRING_LITERAL2:
      case STRING_LITERAL_LONG1:
      case STRING_LITERAL_LONG2:
        gn = RDFLiteral();
        {
          if (true) return asExpr(gn);
        }
        break;
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
        gn = NumericLiteral();
        {
          if (true) return asExpr(gn);
        }
        break;
      case TRUE:
      case FALSE:
        gn = BooleanLiteral();
        {
          if (true) return asExpr(gn);
        }
        break;
      case VAR1:
      case VAR2:
        gn = Var();
        {
          if (true) return asExpr(gn);
        }
        break;
      default:
        jj_la1[136] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> BrackettedExpression() throws ParseException {
    Expr<Node> expr;
    jj_consume_token(LPAREN);
    expr = Expression();
    jj_consume_token(RPAREN);
    {
      if (true) return expr;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> BuiltInCall() throws ParseException {
    Expr<Node> expr;
    Expr<Node> expr1 = null;
    Expr<Node> expr2 = null;
    Node gn;
    ExprList<Node> a;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case COUNT:
      case MIN:
      case MAX:
      case SUM:
      case AVG:
      case SAMPLE:
      case GROUP_CONCAT:
        expr = Aggregate();
        {
          if (true) return expr;
        }
        break;
      case STR:
        jj_consume_token(STR);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_Str(expr);
        }
        break;
      case LANG:
        jj_consume_token(LANG);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_Lang(expr);
        }
        break;
      case LANGMATCHES:
        jj_consume_token(LANGMATCHES);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_LangMatches(expr1, expr2);
        }
        break;
      case DTYPE:
        jj_consume_token(DTYPE);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_Datatype(expr);
        }
        break;
      case BOUND:
        jj_consume_token(BOUND);
        jj_consume_token(LPAREN);
        gn = Var();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_Bound(create_ExprVar(gn));
        }
        break;
      case IRI:
        jj_consume_token(IRI);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_IRI(expr);
        }
        break;
      case URI:
        jj_consume_token(URI);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_URI(expr);
        }
        break;
      case BNODE:
        jj_consume_token(BNODE);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case LPAREN:
            jj_consume_token(LPAREN);
            expr1 = Expression();
            jj_consume_token(RPAREN);
            {
              if (true) return create_E_BNode(expr1);
            }
            break;
          case NIL:
            jj_consume_token(NIL);
            {
              if (true) return create_E_BNode();
            }
            break;
          default:
            jj_la1[137] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        break;
      case RAND:
        jj_consume_token(RAND);
        jj_consume_token(NIL);
        {
          if (true) return create_E_Random();
        }
        break;
      case ABS:
        jj_consume_token(ABS);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_NumAbs(expr1);
        }
        break;
      case CEIL:
        jj_consume_token(CEIL);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_NumCeiling(expr1);
        }
        break;
      case FLOOR:
        jj_consume_token(FLOOR);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_NumFloor(expr1);
        }
        break;
      case ROUND:
        jj_consume_token(ROUND);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_NumRound(expr1);
        }
        break;
      case CONCAT:
        jj_consume_token(CONCAT);
        a = ExpressionList();
        {
          if (true) return create_E_StrConcat(a);
        }
        break;
      case SUBSTR:
        expr = SubstringExpression();
        {
          if (true) return expr;
        }
        break;
      case STRLEN:
        jj_consume_token(STRLEN);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrLength(expr1);
        }
        break;
      case REPLACE:
        expr = StrReplaceExpression();
        {
          if (true) return expr;
        }
        break;
      case UCASE:
        jj_consume_token(UCASE);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrUpperCase(expr1);
        }
        break;
      case LCASE:
        jj_consume_token(LCASE);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrLowerCase(expr1);
        }
        break;
      case ENCODE_FOR_URI:
        jj_consume_token(ENCODE_FOR_URI);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrEncodeForURI(expr1);
        }
        break;
      case CONTAINS:
        jj_consume_token(CONTAINS);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrContains(expr1, expr2);
        }
        break;
      case STRSTARTS:
        jj_consume_token(STRSTARTS);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrStartsWith(expr1, expr2);
        }
        break;
      case STRENDS:
        jj_consume_token(STRENDS);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrEndsWith(expr1, expr2);
        }
        break;
      case STRBEFORE:
        jj_consume_token(STRBEFORE);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrBefore(expr1, expr2);
        }
        break;
      case STRAFTER:
        jj_consume_token(STRAFTER);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrAfter(expr1, expr2);
        }
        break;
      case YEAR:
        jj_consume_token(YEAR);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_DateTimeYear(expr1);
        }
        break;
      case MONTH:
        jj_consume_token(MONTH);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_DateTimeMonth(expr1);
        }
        break;
      case DAY:
        jj_consume_token(DAY);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_DateTimeDay(expr1);
        }
        break;
      case HOURS:
        jj_consume_token(HOURS);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_DateTimeHours(expr1);
        }
        break;
      case MINUTES:
        jj_consume_token(MINUTES);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_DateTimeMinutes(expr1);
        }
        break;
      case SECONDS:
        jj_consume_token(SECONDS);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_DateTimeSeconds(expr1);
        }
        break;
      case TIMEZONE:
        jj_consume_token(TIMEZONE);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_DateTimeTimezone(expr1);
        }
        break;
      case TZ:
        jj_consume_token(TZ);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_DateTimeTZ(expr1);
        }
        break;
      case NOW:
        jj_consume_token(NOW);
        jj_consume_token(NIL);
        {
          if (true) return create_E_Now();
        }
        break;
      case UUID:
        jj_consume_token(UUID);
        jj_consume_token(NIL);
        {
          if (true) return create_E_UUID();
        }
        break;
      case STRUUID:
        jj_consume_token(STRUUID);
        jj_consume_token(NIL);
        {
          if (true) return create_E_StrUUID();
        }
        break;
      case MD5:
        jj_consume_token(MD5);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_MD5(expr1);
        }
        break;
      case SHA1:
        jj_consume_token(SHA1);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_SHA1(expr1);
        }
        break;
      case SHA256:
        jj_consume_token(SHA256);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_SHA256(expr1);
        }
        break;
      case SHA384:
        jj_consume_token(SHA384);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_SHA384(expr1);
        }
        break;
      case SHA512:
        jj_consume_token(SHA512);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_SHA512(expr1);
        }
        break;
      case COALESCE:
        jj_consume_token(COALESCE);
        a = ExpressionList();
        {
          if (true) return create_E_Coalesce(a);
        }
        break;
      case IF:
        jj_consume_token(IF);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(COMMA);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_Conditional(expr, expr1, expr2);
        }
        break;
      case STRLANG:
        jj_consume_token(STRLANG);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrLang(expr1, expr2);
        }
        break;
      case STRDT:
        jj_consume_token(STRDT);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_StrDatatype(expr1, expr2);
        }
        break;
      case SAME_TERM:
        jj_consume_token(SAME_TERM);
        jj_consume_token(LPAREN);
        expr1 = Expression();
        jj_consume_token(COMMA);
        expr2 = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_SameTerm(expr1, expr2);
        }
        break;
      case IS_IRI:
        jj_consume_token(IS_IRI);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_IsIRI(expr);
        }
        break;
      case IS_URI:
        jj_consume_token(IS_URI);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_IsURI(expr);
        }
        break;
      case IS_BLANK:
        jj_consume_token(IS_BLANK);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_IsBlank(expr);
        }
        break;
      case IS_LITERAL:
        jj_consume_token(IS_LITERAL);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_IsLiteral(expr);
        }
        break;
      case IS_NUMERIC:
        jj_consume_token(IS_NUMERIC);
        jj_consume_token(LPAREN);
        expr = Expression();
        jj_consume_token(RPAREN);
        {
          if (true) return create_E_IsNumeric(expr);
        }
        break;
      case REGEX:
        expr = RegexExpression();
        {
          if (true) return expr;
        }
        break;
      case EXISTS:
        expr = ExistsFunc();
        {
          if (true) return expr;
        }
        break;
      case NOT:
        expr = NotExistsFunc();
        {
          if (true) return expr;
        }
        break;
      default:
        jj_la1[138] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> RegexExpression() throws ParseException {
    Expr<Node> expr;
    Expr<Node> patExpr = null;
    Expr<Node> flagsExpr = null;
    jj_consume_token(REGEX);
    jj_consume_token(LPAREN);
    expr = Expression();
    jj_consume_token(COMMA);
    patExpr = Expression();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        flagsExpr = Expression();
        break;
      default:
        jj_la1[139] = jj_gen;
        ;
    }
    jj_consume_token(RPAREN);
    {
      if (true) return create_E_Regex(expr, patExpr, flagsExpr);
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> SubstringExpression() throws ParseException {
    Expr<Node> expr1;
    Expr<Node> expr2 = null;
    Expr<Node> expr3 = null;
    jj_consume_token(SUBSTR);
    jj_consume_token(LPAREN);
    expr1 = Expression();
    jj_consume_token(COMMA);
    expr2 = Expression();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        expr3 = Expression();
        break;
      default:
        jj_la1[140] = jj_gen;
        ;
    }
    jj_consume_token(RPAREN);
    {
      if (true) return create_E_StrSubstring(expr1, expr2, expr3);
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> StrReplaceExpression() throws ParseException {
    Expr<Node> expr1;
    Expr<Node> expr2 = null;
    Expr<Node> expr3 = null;
    Expr<Node> expr4 = null;
    jj_consume_token(REPLACE);
    jj_consume_token(LPAREN);
    expr1 = Expression();
    jj_consume_token(COMMA);
    expr2 = Expression();
    jj_consume_token(COMMA);
    expr3 = Expression();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        expr4 = Expression();
        break;
      default:
        jj_la1[141] = jj_gen;
        ;
    }
    jj_consume_token(RPAREN);
    {
      if (true) return create_E_StrReplace(expr1, expr2, expr3, expr4);
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> ExistsFunc() throws ParseException {
    Element<Node> el;
    jj_consume_token(EXISTS);
    el = GroupGraphPattern();
    {
      if (true) return createExprExists(el);
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> NotExistsFunc() throws ParseException {
    Element<Node> el;
    jj_consume_token(NOT);
    jj_consume_token(EXISTS);
    el = GroupGraphPattern();
    {
      if (true) return createExprNotExists(el);
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> Aggregate() throws ParseException {
    Aggregator<Node> agg = null;
    String sep = null;
    boolean distinct = false;
    Expr<Node> expr = null;
    Expr<Node> expr2 = null;
    ExprList<Node> a = new ExprList<Node>();
    ExprList<Node> ordered = new ExprList<Node>();
    Token t;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case COUNT:
        t = jj_consume_token(COUNT);
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            jj_consume_token(DISTINCT);
            distinct = true;
            break;
          default:
            jj_la1[142] = jj_gen;
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case STAR:
            jj_consume_token(STAR);
            break;
          case IRIref:
          case PNAME_NS:
          case PNAME_LN:
          case VAR1:
          case VAR2:
          case EXISTS:
          case NOT:
          case COUNT:
          case MIN:
          case MAX:
          case SUM:
          case AVG:
          case SAMPLE:
          case GROUP_CONCAT:
          case BOUND:
          case COALESCE:
          case IF:
          case BNODE:
          case IRI:
          case URI:
          case STR:
          case STRLANG:
          case STRDT:
          case DTYPE:
          case LANG:
          case LANGMATCHES:
          case IS_URI:
          case IS_IRI:
          case IS_BLANK:
          case IS_LITERAL:
          case IS_NUMERIC:
          case REGEX:
          case SAME_TERM:
          case RAND:
          case ABS:
          case CEIL:
          case FLOOR:
          case ROUND:
          case CONCAT:
          case SUBSTR:
          case STRLEN:
          case REPLACE:
          case UCASE:
          case LCASE:
          case ENCODE_FOR_URI:
          case CONTAINS:
          case STRSTARTS:
          case STRENDS:
          case STRBEFORE:
          case STRAFTER:
          case YEAR:
          case MONTH:
          case DAY:
          case HOURS:
          case MINUTES:
          case SECONDS:
          case TIMEZONE:
          case TZ:
          case NOW:
          case UUID:
          case STRUUID:
          case MD5:
          case SHA1:
          case SHA256:
          case SHA384:
          case SHA512:
          case TRUE:
          case FALSE:
          case INTEGER:
          case DECIMAL:
          case DOUBLE:
          case INTEGER_POSITIVE:
          case DECIMAL_POSITIVE:
          case DOUBLE_POSITIVE:
          case INTEGER_NEGATIVE:
          case DECIMAL_NEGATIVE:
          case DOUBLE_NEGATIVE:
          case STRING_LITERAL1:
          case STRING_LITERAL2:
          case STRING_LITERAL_LONG1:
          case STRING_LITERAL_LONG2:
          case LPAREN:
          case BANG:
          case PLUS:
          case MINUS:
            expr = Expression();
            break;
          default:
            jj_la1[143] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        jj_consume_token(RPAREN);
        if (expr == null) {
          agg = createCount(distinct);
        }
        if (expr != null) {
          agg = createCountExpr(distinct, expr);
        }
        break;
      case SUM:
        t = jj_consume_token(SUM);
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            jj_consume_token(DISTINCT);
            distinct = true;
            break;
          default:
            jj_la1[144] = jj_gen;
            ;
        }
        expr = Expression();
        jj_consume_token(RPAREN);
        agg = createSum(distinct, expr);
        break;
      case MIN:
        t = jj_consume_token(MIN);
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            jj_consume_token(DISTINCT);
            distinct = true;
            break;
          default:
            jj_la1[145] = jj_gen;
            ;
        }
        expr = Expression();
        jj_consume_token(RPAREN);
        agg = createMin(distinct, expr);
        break;
      case MAX:
        t = jj_consume_token(MAX);
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            jj_consume_token(DISTINCT);
            distinct = true;
            break;
          default:
            jj_la1[146] = jj_gen;
            ;
        }
        expr = Expression();
        jj_consume_token(RPAREN);
        agg = createMax(distinct, expr);
        break;
      case AVG:
        t = jj_consume_token(AVG);
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            jj_consume_token(DISTINCT);
            distinct = true;
            break;
          default:
            jj_la1[147] = jj_gen;
            ;
        }
        expr = Expression();
        jj_consume_token(RPAREN);
        agg = createAvg(distinct, expr);
        break;
      case SAMPLE:
        t = jj_consume_token(SAMPLE);
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            jj_consume_token(DISTINCT);
            distinct = true;
            break;
          default:
            jj_la1[148] = jj_gen;
            ;
        }
        expr = Expression();
        jj_consume_token(RPAREN);
        agg = createSample(distinct, expr);
        break;
      case GROUP_CONCAT:
        t = jj_consume_token(GROUP_CONCAT);
        jj_consume_token(LPAREN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case DISTINCT:
            t = jj_consume_token(DISTINCT);
            distinct = true;
            break;
          default:
            jj_la1[149] = jj_gen;
            ;
        }
        expr = Expression();
        a.add(expr);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case SEMICOLON:
            jj_consume_token(SEMICOLON);
            jj_consume_token(SEPARATOR);
            jj_consume_token(EQ);
            sep = String();
            break;
          default:
            jj_la1[150] = jj_gen;
            ;
        }
        jj_consume_token(RPAREN);
        agg = createGroupConcat(distinct, expr, sep, ordered);
        break;
      default:
        jj_la1[151] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    if (!allowAggregatesInExpressions)
      throwParseException(
          "Aggregate expression not legal at this point", t.beginLine, t.beginColumn);
    Expr exprAgg = getQuery().allocAggregate(agg);
    {
      if (true) return exprAgg;
    }
    throw new Error("Missing return statement in function");
  }

  public final Expr<Node> iriOrFunction() throws ParseException {
    String iri;
    ExprList<Node> a = null;
    ExprList<Node> params = null;
    boolean distinct = false;
    iri = iri();
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LPAREN:
      case NIL:
        a = ArgList();
        break;
      default:
        jj_la1[152] = jj_gen;
        ;
    }
    if (a == null) {
      if (true) return asExpr(createNode(iri));
    }
    //    if ( AggregateRegistry.isRegistered(iri) ) {
    //         if ( ! allowAggregatesInExpressions )
    //            throwParseException("Aggregate expression not legal at this point : "+iri, -1, -1)
    // ;
    //         Aggregator agg = createCustom(true, false, iri, a) ;
    //         Expr exprAgg = getQuery().allocAggregate(agg) ;
    //         {if (true) return exprAgg ;}
    //      }
    {
      if (true) return create_E_Function(iri, a);
    }
    throw new Error("Missing return statement in function");
  }

  public final Node RDFLiteral() throws ParseException {
    Token t;
    String lex = null;
    lex = String();
    String lang = null;
    String uri = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LANGTAG:
      case DATATYPE:
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
          case LANGTAG:
            t = jj_consume_token(LANGTAG);
            lang = stripChars(t.image, 1);
            break;
          case DATATYPE:
            jj_consume_token(DATATYPE);
            uri = iri();
            break;
          default:
            jj_la1[153] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        break;
      default:
        jj_la1[154] = jj_gen;
        ;
    }
    {
      if (true) return createLiteral(lex, lang, uri);
    }
    throw new Error("Missing return statement in function");
  }

  public final Node NumericLiteral() throws ParseException {
    Node n;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case INTEGER:
      case DECIMAL:
      case DOUBLE:
        n = NumericLiteralUnsigned();
        break;
      case INTEGER_POSITIVE:
      case DECIMAL_POSITIVE:
      case DOUBLE_POSITIVE:
        n = NumericLiteralPositive();
        break;
      case INTEGER_NEGATIVE:
      case DECIMAL_NEGATIVE:
      case DOUBLE_NEGATIVE:
        n = NumericLiteralNegative();
        break;
      default:
        jj_la1[155] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if (true) return n;
    }
    throw new Error("Missing return statement in function");
  }

  public final Node NumericLiteralUnsigned() throws ParseException {
    Token t;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case INTEGER:
        t = jj_consume_token(INTEGER);
        {
          if (true) return createLiteralInteger(t.image);
        }
        break;
      case DECIMAL:
        t = jj_consume_token(DECIMAL);
        {
          if (true) return createLiteralDecimal(t.image);
        }
        break;
      case DOUBLE:
        t = jj_consume_token(DOUBLE);
        {
          if (true) return createLiteralDouble(t.image);
        }
        break;
      default:
        jj_la1[156] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Node NumericLiteralPositive() throws ParseException {
    Token t;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case INTEGER_POSITIVE:
        t = jj_consume_token(INTEGER_POSITIVE);
        {
          if (true) return createLiteralInteger(t.image);
        }
        break;
      case DECIMAL_POSITIVE:
        t = jj_consume_token(DECIMAL_POSITIVE);
        {
          if (true) return createLiteralDecimal(t.image);
        }
        break;
      case DOUBLE_POSITIVE:
        t = jj_consume_token(DOUBLE_POSITIVE);
        {
          if (true) return createLiteralDouble(t.image);
        }
        break;
      default:
        jj_la1[157] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Node NumericLiteralNegative() throws ParseException {
    Token t;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case INTEGER_NEGATIVE:
        t = jj_consume_token(INTEGER_NEGATIVE);
        {
          if (true) return createLiteralInteger(t.image);
        }
        break;
      case DECIMAL_NEGATIVE:
        t = jj_consume_token(DECIMAL_NEGATIVE);
        {
          if (true) return createLiteralDecimal(t.image);
        }
        break;
      case DOUBLE_NEGATIVE:
        t = jj_consume_token(DOUBLE_NEGATIVE);
        {
          if (true) return createLiteralDouble(t.image);
        }
        break;
      default:
        jj_la1[158] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Node BooleanLiteral() throws ParseException {
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case TRUE:
        jj_consume_token(TRUE);
        {
          if (true) return XSD_TRUE;
        }
        break;
      case FALSE:
        jj_consume_token(FALSE);
        {
          if (true) return XSD_FALSE;
        }
        break;
      default:
        jj_la1[159] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final String String() throws ParseException {
    Token t;
    String lex;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case STRING_LITERAL1:
        t = jj_consume_token(STRING_LITERAL1);
        lex = stripQuotes(t.image);
        break;
      case STRING_LITERAL2:
        t = jj_consume_token(STRING_LITERAL2);
        lex = stripQuotes(t.image);
        break;
      case STRING_LITERAL_LONG1:
        t = jj_consume_token(STRING_LITERAL_LONG1);
        lex = stripQuotes3(t.image);
        break;
      case STRING_LITERAL_LONG2:
        t = jj_consume_token(STRING_LITERAL_LONG2);
        lex = stripQuotes3(t.image);
        break;
      default:
        jj_la1[160] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    lex = unescapeStr(lex, t.beginLine, t.beginColumn);
    {
      if (true) return lex;
    }
    throw new Error("Missing return statement in function");
  }

  public final String iri() throws ParseException {
    String iri;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case IRIref:
        iri = IRIREF();
        {
          if (true) return iri;
        }
        break;
      case PNAME_NS:
      case PNAME_LN:
        iri = PrefixedName();
        {
          if (true) return iri;
        }
        break;
      default:
        jj_la1[161] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final String PrefixedName() throws ParseException {
    Token t;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case PNAME_LN:
        t = jj_consume_token(PNAME_LN);
        {
          if (true) return resolvePName(t.image, t.beginLine, t.beginColumn);
        }
        break;
      case PNAME_NS:
        t = jj_consume_token(PNAME_NS);
        {
          if (true) return resolvePName(t.image, t.beginLine, t.beginColumn);
        }
        break;
      default:
        jj_la1[162] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final Node BlankNode() throws ParseException {
    Token t = null;
    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BLANK_NODE_LABEL:
        t = jj_consume_token(BLANK_NODE_LABEL);
        {
          if (true) return createBNode(t.image, t.beginLine, t.beginColumn);
        }
        break;
      case ANON:
        t = jj_consume_token(ANON);
        {
          if (true) return createBNode(t.beginLine, t.beginColumn);
        }
        break;
      default:
        jj_la1[163] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public final String IRIREF() throws ParseException {
    Token t;
    t = jj_consume_token(IRIref);
    {
      if (true) return resolveQuotedIRI(t.image, t.beginLine, t.beginColumn);
    }
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public SPARQLParser11TokenManager token_source;

  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;

  private int jj_ntk;
  private int jj_gen;
  private final int[] jj_la1 = new int[164];
  private static int[] jj_la1_0;
  private static int[] jj_la1_1;
  private static int[] jj_la1_2;
  private static int[] jj_la1_3;
  private static int[] jj_la1_4;
  private static int[] jj_la1_5;
  private static int[] jj_la1_6;

  static {
    jj_la1_init_0();
    jj_la1_init_1();
    jj_la1_init_2();
    jj_la1_init_3();
    jj_la1_init_4();
    jj_la1_init_5();
    jj_la1_init_6();
  }

  private static void jj_la1_init_0() {
    jj_la1_0 =
        new int[] {
          0xe400000,
          0x300000,
          0x300000,
          0x0,
          0x1800000,
          0x1800000,
          0xc000,
          0xc000,
          0xc000,
          0x0,
          0x0,
          0xfc00,
          0x0,
          0xdc00,
          0xdc00,
          0x0,
          0x0,
          0x0,
          0x1c00,
          0x0,
          0x0,
          0x0,
          0x40000000,
          0x30000000,
          0xdc00,
          0x0,
          0xdc00,
          0x1c00,
          0xdc00,
          0x0,
          0xdc00,
          0xdc00,
          0x20000000,
          0x10000000,
          0x30000000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x1c00,
          0x0,
          0x1c00,
          0x0,
          0xfc00,
          0x0,
          0x0,
          0xfc00,
          0xfc00,
          0xfc00,
          0x0,
          0x400000,
          0xfc00,
          0x0,
          0x0,
          0xfc00,
          0xfc00,
          0x0,
          0x0,
          0x0,
          0xc000,
          0x1c00,
          0xc000,
          0x0,
          0x0,
          0x1c00,
          0x0,
          0x1c00,
          0x0,
          0x1c00,
          0x800000,
          0x0,
          0x0,
          0x0,
          0x0,
          0xfc00,
          0xfc00,
          0x0,
          0xfc00,
          0x8dc00,
          0x0,
          0x8dc00,
          0x8dc00,
          0x0,
          0xfc00,
          0x8dc00,
          0x8dc00,
          0x0,
          0x8dc00,
          0x8dc00,
          0x0,
          0x0,
          0x0,
          0x0,
          0x81c00,
          0x0,
          0x81c00,
          0x0,
          0x81c00,
          0x81c00,
          0x81c00,
          0x81c00,
          0x0,
          0x0,
          0xfc00,
          0xfc00,
          0xfc00,
          0xfc00,
          0xfc00,
          0xdc00,
          0xfc00,
          0xc000,
          0x3c00,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xdc00,
          0xdc00,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x800000,
          0xdc00,
          0x800000,
          0x800000,
          0x800000,
          0x800000,
          0x800000,
          0x800000,
          0x0,
          0x0,
          0x0,
          0x10000,
          0x10000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x1c00,
          0x1800,
          0x2000,
        };
  }

  private static void jj_la1_init_1() {
    jj_la1_1 =
        new int[] {
          0x0,
          0x0,
          0x0,
          0x20,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x20,
          0x20,
          0x0,
          0x60,
          0x0,
          0x0,
          0x20,
          0x40,
          0x20,
          0x10,
          0x40,
          0x20000,
          0x40000,
          0x0,
          0x0,
          0xdbe0c000,
          0x10000,
          0xdbe0c000,
          0xdbe0c000,
          0xdbe0c00c,
          0xc,
          0xdbe0c000,
          0xdbe0c00c,
          0x0,
          0x0,
          0x0,
          0x1,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x10,
          0x100,
          0x100,
          0x110,
          0x0,
          0x100,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x20003b01,
          0x0,
          0x0,
          0x0,
          0x0,
          0x20003b01,
          0x0,
          0x0,
          0x2,
          0x0,
          0x0,
          0x0,
          0x2,
          0x0,
          0x2,
          0x400,
          0xdbe0c000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x8000,
          0x8000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xdbe0c000,
          0xdbe0c000,
          0x0,
          0xdbe0c000,
          0x0,
          0x0,
          0x0,
          0x0,
          0xdbe0c000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x1be00000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
        };
  }

  private static void jj_la1_init_2() {
    jj_la1_2 =
        new int[] {
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xfffffffe,
          0x0,
          0xfffffffe,
          0xfffffffe,
          0xfffffffe,
          0x0,
          0xfffffffe,
          0xfffffffe,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xfffffffe,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x1,
          0x1,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xfffffffe,
          0xfffffffe,
          0x0,
          0xfffffffe,
          0x0,
          0x0,
          0x0,
          0x0,
          0xfffffffe,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
        };
  }

  private static void jj_la1_init_3() {
    jj_la1_3 =
        new int[] {
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xeffff,
          0x0,
          0xeffff,
          0xeffff,
          0xeffff,
          0x0,
          0xeffff,
          0xeffff,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xff800000,
          0xff800000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x800000,
          0x1800000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x0,
          0x0,
          0x300000,
          0x300000,
          0x300000,
          0x0,
          0x0,
          0x300000,
          0x0,
          0x0,
          0x300000,
          0x300000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x0,
          0x300000,
          0x0,
          0xeffff,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x300000,
          0x0,
          0x300000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x300000,
          0x300000,
          0x300000,
          0x300000,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x3effff,
          0x3effff,
          0x0,
          0xeffff,
          0x0,
          0x0,
          0x0,
          0x0,
          0x3effff,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x300000,
          0x0,
          0x0,
          0x0,
          0x0,
        };
  }

  private static void jj_la1_init_4() {
    jj_la1_4 =
        new int[] {
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x20000000,
          0x20000000,
          0x20000000,
          0x0,
          0x0,
          0xbe1ff000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x20000000,
          0x0,
          0x20000000,
          0x20000000,
          0x20000000,
          0x0,
          0x20000000,
          0x20000000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x213,
          0x213,
          0x8,
          0x20,
          0x8,
          0x8,
          0x8,
          0x8,
          0x8,
          0x8,
          0x200,
          0x0,
          0x0,
          0x400,
          0x0,
          0x0,
          0x80,
          0x180,
          0xbe1ff000,
          0x0,
          0x0,
          0xbe1ff000,
          0xbe1ff000,
          0xbe1ff000,
          0x0,
          0x0,
          0xbe1ff000,
          0x0,
          0x0,
          0xbe1ff000,
          0xbe1ff000,
          0x0,
          0x0,
          0x8,
          0xa0000000,
          0x1e1ff000,
          0x0,
          0xa0000000,
          0xa0000000,
          0x1e1ff000,
          0xa0000000,
          0x1e1ff000,
          0x0,
          0x20000000,
          0x0,
          0x0,
          0xa0000000,
          0x0,
          0xa0000000,
          0xbe1ff000,
          0xbe1ff000,
          0x0,
          0xbe1ff000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xbe1ff000,
          0x20000000,
          0x20000000,
          0x0,
          0x20000000,
          0x20000000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x20000000,
          0x0,
          0x20000000,
          0x0,
          0x0,
          0x20000000,
          0x0,
          0x0,
          0x20000000,
          0x20000000,
          0xbe1ff000,
          0xbe1ff000,
          0xbe1ff000,
          0xbe1ff000,
          0x9e1ff000,
          0x0,
          0x0,
          0x0,
          0x9e1ff000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x1f8000,
          0x1f8000,
          0x0,
          0x0,
          0x1f8000,
          0x0,
          0x0,
          0x3e1ff000,
          0x3e1ff000,
          0xa0000000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x3e1ff000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0xa0000000,
          0x0,
          0x0,
          0x1ff000,
          0x7000,
          0x38000,
          0x1c0000,
          0x0,
          0x1e000000,
          0x0,
          0x0,
          0x0,
        };
  }

  private static void jj_la1_init_5() {
    jj_la1_5 =
        new int[] {
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x200000,
          0x0,
          0x0,
          0x14,
          0x1,
          0x0,
          0x200000,
          0x0,
          0x1,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x20,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x14,
          0x0,
          0x80,
          0x14,
          0x14,
          0x14,
          0x80,
          0x0,
          0x14,
          0x1,
          0x80,
          0x14,
          0x14,
          0x80,
          0x1,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x40,
          0x0,
          0x40,
          0x0,
          0x14,
          0x14,
          0x80,
          0x14,
          0x0,
          0x20,
          0x0,
          0x0,
          0x40,
          0x14,
          0x4004000,
          0x4004000,
          0x20,
          0x4004000,
          0x4004000,
          0x40,
          0x2000000,
          0x400000,
          0x20280000,
          0x4004000,
          0x20280000,
          0x4000,
          0x2000000,
          0x4000000,
          0x4000000,
          0x0,
          0x4000000,
          0x4,
          0x4,
          0x14,
          0x14,
          0x14,
          0x14,
          0x10,
          0x0,
          0x10,
          0x0,
          0x10,
          0x20000,
          0x40000,
          0x3f00,
          0x3f00,
          0x180000,
          0x0,
          0x600000,
          0x600000,
          0x180000,
          0x600000,
          0x600000,
          0x184000,
          0x0,
          0x0,
          0x0,
          0x40,
          0x40,
          0x40,
          0x0,
          0x384000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x20,
          0x0,
          0x0,
          0x800000,
          0x800000,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x0,
          0x10,
        };
  }

  private static void jj_la1_init_6() {
    jj_la1_6 =
        new int[] {
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
          0x0, 0x0,
        };
  }

  /** Constructor with InputStream. */
  public SPARQLParser11(java.io.InputStream stream) {
    this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SPARQLParser11(java.io.InputStream stream, String encoding) {
    try {
      jj_input_stream = new JavaCharStream(stream, encoding, 1, 1);
    } catch (java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    token_source = new SPARQLParser11TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 164; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
    ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try {
      jj_input_stream.ReInit(stream, encoding, 1, 1);
    } catch (java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 164; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public SPARQLParser11(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new SPARQLParser11TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 164; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 164; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public SPARQLParser11(SPARQLParser11TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 164; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(SPARQLParser11TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 164; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  /** Get the next Token. */
  public final Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  /** Get the specific Token. */
  public final Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt = token.next) == null)
      return (jj_ntk = (token.next = token_source.getNextToken()).kind);
    else return (jj_ntk = jj_nt.kind);
  }

  private List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[201];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 164; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1 << j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1 << j)) != 0) {
            la1tokens[32 + j] = true;
          }
          if ((jj_la1_2[i] & (1 << j)) != 0) {
            la1tokens[64 + j] = true;
          }
          if ((jj_la1_3[i] & (1 << j)) != 0) {
            la1tokens[96 + j] = true;
          }
          if ((jj_la1_4[i] & (1 << j)) != 0) {
            la1tokens[128 + j] = true;
          }
          if ((jj_la1_5[i] & (1 << j)) != 0) {
            la1tokens[160 + j] = true;
          }
          if ((jj_la1_6[i] & (1 << j)) != 0) {
            la1tokens[192 + j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 201; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  public final void enable_tracing() {}

  /** Disable tracing. */
  public final void disable_tracing() {}
}
